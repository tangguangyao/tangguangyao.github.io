<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="前端修炼之路" />



  <meta name="keywords" content="前端,javascript" />





  <link rel="shorticon icon" type="image/x-icon" href="/img/favicon.ico?v=0.4.5.1" />


<meta name="description" content="前端修炼之路">
<meta property="og:type" content="website">
<meta property="og:title" content="Yao's 前端修炼之路">
<meta property="og:url" content="http://tangguangyao.github.io/page/2/index.html">
<meta property="og:site_name" content="Yao's 前端修炼之路">
<meta property="og:description" content="前端修炼之路">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yao's 前端修炼之路">
<meta name="twitter:description" content="前端修炼之路">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Yao's 前端修炼之路 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?e35a2df9e882a5f8ed351d0f022fa689";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Yao's 前端修炼之路</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/14/AMD的一道面试题/" itemprop="url">
                AMD的一道面试题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-14T10:59:49+08:00" content="2016-01-14">
            2016-01-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/amd.jpg" alt="AMD的一道面试题"></p>
<p>模块化现在应该已经成为了稍微复杂一点前端开发的标配了。在es6中，都已经支持了的模块化。  </p>
<p>之前的面试中，一直感觉模块化AMD,CMD没有什么可以问的，不过昨天面试突然想到一个题目：<br>对于一个AMD的模式下</p>
<p>文件<code>d.js</code>如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>a.js</code>,<code>b.js</code>,<code>c.js</code> 文件分别是什么时候加载的，如何加载的？</p>
<p>题目不难</p>
<p>答案是<code>a.js</code> 和 <code>c.js</code> 是在加载完<code>d.js</code>后就加载。<br><code>b.js</code>是在执行到这一行时异步加载的。</p>
<p>具体分析：</p>
<p>我没有看过<code>require.js</code>的源码，我们使用的是<code>esl.js</code>（也是一个AMD的模块加载器）,但是他们的实现原理应该差不多。</p>
<p>我从<code>esl.js</code>的角度解读一下：</p>
<h3 id="同步加载，异步加载">同步加载，异步加载</h3><p>首先大家需要知道AMD里面一个同步加载和异步加载的概念。</p>
<p>从概念上面理解，同步就是当我执行到<code>require(&#39;a&#39;);</code>时，我需要同步的执行<code>a.js</code>里面的内容，也就是需要在执行到这句话时<code>a.js</code>必须已经加载好了，这样才能到达同步。</p>
<p>而对于 <code>require([&#39;b&#39;], function (b) {});</code>,我执行到这一步时，是异步的发出请求，然后异步等待<code>b.js</code>的返回+执行。</p>
<h3 id="同步加载的实现原理">同步加载的实现原理</h3><p>我们从概念上面理解的同步加载的原理，现在看看<code>esl.js</code>的实践。<br>这里面需要处理两个核心步骤  </p>
<ol>
<li>执行到<code>require(&#39;a&#39;);</code>时，<code>a.js</code>必须已经加载好了；</li>
<li><code>a.js</code>文件里面的所有<code>require(&#39;*&#39;)</code>，也都必须加载好了，保证在执行<code>a.js</code>时，所有<code>a.js</code>依赖的同步文件都能同步执行；</li>
</ol>
<p>对于第一步的实现，大概原理是这样的，在加载好了<code>d.js</code>后，会正则匹配一次文件里面的同步依赖<code>require(&#39;*&#39;);</code>，例如匹配出了 <code>a.js</code>和<code>c.js</code>，然后继续加载<code>a.js</code>和<code>c.js</code>。  </p>
<p>对于第二部，其实就是一个递归处理，直到没有下一步的依赖为止。</p>
<h3 id="同步加载另外一种处理方法">同步加载另外一种处理方法</h3><p>上面有一部正则逻辑，可见如果使用这种方式，在执行代码前，js需要全部正则一次所有模块化代码的。这样性能是不是有一个无谓的耗损。  </p>
<p>那么我们一般怎么处理了？  </p>
<p>大家一般都了解过打包编译，例如在使用<code>Requirejs</code>时，线上环境的代码会经过<code>r.js</code>处理一次。  </p>
<p>那么<code>d.js</code>文件应该会处理如下 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">	<span class="string">'path/b'</span>,</span><br><span class="line">	[<span class="string">'require'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>define方法会增加第一个和第二个参数  </p>
<p>第一个参数是按照路径生成一个具名id<br>第二个参数是此文件所依赖的同步文件</p>
<p>这时当模块在解析这个<code>b,js</code>文件时，发现如果存在第二个参数，就会直接解析所需依赖部分，而省去了正则这一步。  </p>
<p>我们正则这一步转换到了打包编译中去分析，这样就省掉了浏览器加载时去正则所有AMD文件这一步。  </p>
<p>那么为什么我们不在开发环境中直接使用<code>[&#39;require&#39;, &#39;a&#39;, &#39;b&#39;]</code>方式，我理解目的是为了提高开发便捷性，我们不需要再增加一个<code>require(&#39;*&#39;)</code>都在中括号内配置一次，同样删除时也不用去删掉配置。  </p>
<p>因为这一步完全可以在编译时处理。  </p>
<h3 id="打包编译的延生">打包编译的延生</h3><p>不知道大家有没有看过编译后的代码和开发环境代码的区别，对于这个<code>b.js</code>文件，编译后应该是： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">	<span class="string">'path/a'</span>,</span><br><span class="line">	[<span class="string">'require'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(</span><br><span class="line">	<span class="string">'path/c'</span>,</span><br><span class="line">	[<span class="string">'require'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(</span><br><span class="line">	<span class="string">'path/b'</span>,</span><br><span class="line">	[<span class="string">'require'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面可见，<code>a.js</code>和<code>c.js</code>这两个文件被合并到了<code>d.js</code>中，所有文件都加上了具名id。而且这个id的生成规则是更具路径生成的。  </p>
<p>而我们异步加载的<code>b.js</code>文件就没有被打包进来。这是因为我们期望<code>b.js</code>是懒加载的，当使用时在加载，这样也能达到按需加载的目的。</p>
<h3 id="微信公众号">微信公众号</h3><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/05/前端发展论战/" itemprop="url">
                前端发展论战
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-05T13:54:45+08:00" content="2016-01-05">
            2016-01-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/topics.jpg" alt="前端发展论战"></p>
<h2 id="最近很热的讨论">最近很热的讨论</h2><blockquote>
<p>关于『真阿当』对目前流行前端技术的批判 <a href="https://www.zhihu.com/question/38924821" target="_blank" rel="external">https://www.zhihu.com/question/38924821</a></p>
<p>Winter - 我眼中的前端框架jQuery，Angular，React，Vue——以及我看前端架构<a href="http://weibo.com/p/1001603924826640228007" target="_blank" rel="external">http://weibo.com/p/1001603924826640228007</a></p>
<p>关于前端工具变化过快的讨论 <a href="https://www.zhihu.com/question/34449620" target="_blank" rel="external">https://www.zhihu.com/question/34449620</a></p>
<p>我感觉到的前端变化 <a href="http://bbear.me/wo-suo-gan-jue-dao-de-qian-duan-bian-hua/" target="_blank" rel="external">http://bbear.me/wo-suo-gan-jue-dao-de-qian-duan-bian-hua/</a></p>
</blockquote>
<p>上面几篇文章对于前端的发展讨论较多。</p>
<h2 id="前端变化过快的看法">前端变化过快的看法</h2><p>首先，不得不承认前端变化确实太快，对于我而言，react还在了解，没有真正的落地业务时，vue又开始兴起，马上angular2可能又会开始火。。。 </p>
<p>变化如此之快，我们该如何面对？  </p>
<p>第一，我觉得首先需要避免盲目追新，如果对于新框架只是简单的写写demo，意义是不大的。</p>
<p>为什么了？如果没有复杂的项目支撑，你会踩不到框架的坑，你不会体会到框架哪里设计的巧妙，哪里设计的不足。你也很少有机会为了研究巧妙的实现去看部分的源码。而这个过程其实是使用框架的精髓。  </p>
<p>第二，更加深入的加强基础技能，框架会不断更新，更新也会越来越快，只有不断强化一些基础技能，才能够很快的去了解新框架，达到新框架即学即用的能力。</p>
<p>如何提高基础技能呢？就研究下你现在用的框架，或者找一个你觉得很好的框架，深入研究下他的设计思路，源码等等，反复研究，反复体会，花上3个月深入研究一个。当你研究透了，你在看其他框架，相信我，你看的角度会变。</p>
<h2 id="我们对于新技术如何使用">我们对于新技术如何使用</h2><p>现在团队使用的还是百度自己一套mvc框架，但是当我们在尝试新技术时，我们其实可以很快的即学即用的，es6，react，vue这些的使用并没有什么障碍。</p>
<p>即使我们目前工作都是集中在pc端，我们团队的成员也是可以迅速上手移动端的开发的，我理解很大一部分因素都是基础能力比较扎实。</p>
<p>所以我感觉，请放心，如果没有用到最新的技术，不要害怕。</p>
<h2 id="前端的发展">前端的发展</h2><p>个人感觉未来的前端更加偏向解决方案的方式，一个合格的架构师能够根据业务，以及开发成员的状态，选择最合适的开发方式，合作方式。</p>
<p>未来的框架，工程化方案会越来越多，你需要做到的是，能够即插即用的能力。在面对一个新框架时，能够快速判断出框架是否适合于业务，是否能提高开发效率。</p>
<p>回到阿当的微博</p>
<blockquote>
<p>sass和less最近是不是被提起得少了?backbone呢?响应式设计呢?今天说得起劲的angular和rect，是不是半年后也逐渐消停了呢?一切不接地气的性价比不高的伪高端，都会消停的。我相信jquery还能坚挺5年，不相信rect和angular能热过两年。踩jquery的一直不会停，新时髦也不会停。话放在这儿，两年后咱看看。</p>
</blockquote>
<p>我理解，大家不要把注意力放到各种各样的框架上，打好基础，什么新框架都能hold住，岂不是最好。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/16/使用node子进程spawn-exec踩过的坑/" itemprop="url">
                使用node子进程spawn,exec踩过的坑
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-16T15:20:16+08:00" content="2015-12-16">
            2015-12-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/child_process.png" alt="使用node子进程spawn,exec踩过的坑"></p>
<p><em>如何在项目中实现热更新</em>中提到的一个坑child_process的exec使用问题，下面文章会详细介绍下，debug到node源码中的详细介绍，不容错过。</p>
<h2 id="child_process介绍">child_process介绍</h2><p>Nodejs是单线程单进程的，但是有了child_process模块，可以在程序中直接创建子进程，并使用主进程和子进程之间实现通信。  </p>
<p>对于child_process的使用，大家可以找找其他文章，介绍还是比较多的，本文主要讲一下踩过的坑。</p>
<h2 id="踩过的坑">踩过的坑</h2><p>在使用<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a>这个工具时（对于工具的介绍，参考前面的文章<em>如何在项目中实现热更新</em>），发现用子进程启动项目，经常性的挂掉。然后也不知道为什么，甚至怀疑子进程的效率比较低。  </p>
<p>最后为了进一步验证，在同样的环境下，一个直接启动服务，一个是使用<code>require(&#39;child_process&#39;).exec(&#39;...&#39;)</code> 方式启动。  </p>
<p>最后发现使用子进程打开还真的就是使用到一定程度就挂掉。虽然此时也没有什么解决方案，但是至少能把问题定位在子进程上了，而不是其他工具代码导致程序挂掉。  </p>
<h2 id="定位问题">定位问题</h2><p>定位了问题后，网上查找child_process相关资料，发现<a href="http://deadhorse.me/nodejs/2011/12/18/nodejs%E4%B8%ADchild_process%E6%A8%A1%E5%9D%97%E7%9A%84exec%E6%96%B9%E6%B3%95%E5%92%8Cspawn%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">exec与spawn方法的区别与陷阱</a> 这篇文章提到几点：  </p>
<ol>
<li>exec与spawn是有区别的</li>
<li>exec是对spawn的一个封装</li>
<li>最重要的exec比spawn多了一些默认的option </li>
</ol>
<p>基于以上几点有些头绪了，但是还是没有明确的解决方案。  </p>
<p>最后一个办法，直接断点到nodejs的child_process.js模块中尝试看看问题出在哪里。  </p>
<h2 id="exec和spawn的源码区分">exec和spawn的源码区分</h2><p>断点进去看后，豁然开朗，<code>exec</code>是对<code>execFile</code>的封装，<code>execFile</code>又是对<code>spawn</code>的封装。  </p>
<p>每一层封装都是加强一些易用性以及功能。  </p>
<p>直接看源码：  </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exports.exec = </span><br><span class="line">	<span class="function"><span class="keyword">function</span><span class="params">(command <span class="comment">/*, options, callback*/</span>)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">var</span> opts = normalizeExecArgs.apply(<span class="literal">null</span>, arguments);</span><br><span class="line">  		<span class="keyword">return</span> exports.execFile(opts.file,</span><br><span class="line">                          		opts.args,</span><br><span class="line">                          		opts.options,</span><br><span class="line">                          		opts.<span class="keyword">callback</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>exec</code>对于<code>execFile</code>的封装是进行参数处理  </p>
<p>处理的函数：</p>
<p><code>normalizeExecArgs</code>  </p>
<p>关键逻辑</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">    <span class="keyword">file</span> = process.env.comspec || <span class="string">'cmd.exe'</span>;</span><br><span class="line">    args = [<span class="string">'/s'</span>, <span class="string">'/c'</span>, <span class="string">'"'</span> + command + <span class="string">'"'</span>];</span><br><span class="line">    <span class="comment">// Make a shallow copy before patching so we don't clobber the user's</span></span><br><span class="line">    <span class="comment">// options object.</span></span><br><span class="line">    <span class="keyword">options</span> = util._extend(&#123;&#125;, <span class="keyword">options</span>);</span><br><span class="line">    <span class="keyword">options</span>.windowsVerbatimArguments = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">file</span> = <span class="string">'/bin/sh'</span>;</span><br><span class="line">    args = [<span class="string">'-c'</span>, command];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将简单的command命名做一个，win和linux的平台处理。  </p>
<p>此时<code>execFile</code>接受到的就是一个区分平台的<code>command</code>参数。  </p>
<p>然后重点来了，继续debug，<code>execFile</code>中：  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    encoding: <span class="string">'utf8'</span>,</span><br><span class="line">    timeout: <span class="number">0</span>,</span><br><span class="line">    maxBuffer: <span class="number">200</span> * <span class="number">1024</span>,</span><br><span class="line">    killSignal: <span class="string">'SIGTERM'</span>,</span><br><span class="line">    cwd: <span class="literal">null</span>,</span><br><span class="line">    env: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有这么一段，设置了默认的参数。然后后面又是一些参数处理，最后调用<code>spawn</code>方法启动子进程。   </p>
<p>上面的简单流程就是启动一个子进程。到这里都没有什么问题。  </p>
<p>继续看，重点又来了：  </p>
<p>用过子进程应该知道这个<code>child.stderr</code></p>
<p>下面的代码就解答了为什么子进程会挂掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">child.stderr.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    stderrLen += chunk.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stderrLen &gt; options.maxBuffer) &#123;</span><br><span class="line">      ex = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'stderr maxBuffer exceeded.'</span>);</span><br><span class="line">      kill();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!encoding)</span><br><span class="line">        _stderr.push(chunk);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _stderr += chunk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>逻辑就是，记录子进程的log大小，一旦超过<code>maxBuffer</code>就<code>kill</code>掉子进程。  </p>
<p>原来真相在这里。我们在使用<code>exec</code>时，不知道设置<code>maxBuffer</code>，默认的<code>maxBuffer</code>是200K,当我们子进程日志达到200K时，自动<code>kill()</code>掉了。</p>
<h2 id="exec和spawn的使用区分">exec和spawn的使用区分</h2><p> 不过exec确实比spawn在使用上面要好很多</p>
<p> 例如我们执行一个命令</p>
<p> 使用exec</p>
<p> <code>require(&#39;child_process&#39;).exec(&#39;edp webserver start&#39;);</code></p>
<p> 使用spawn</p>
<p> linux下这么搞</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn(</span><br><span class="line">    <span class="string">'/bin/sh'</span>, </span><br><span class="line">    [<span class="string">'-c'</span>,<span class="string">'edp webserver start'</span>],</span><br><span class="line">    &#123;</span><br><span class="line">        cwd: <span class="literal">null</span>,</span><br><span class="line">        env: <span class="literal">null</span>,</span><br><span class="line">        windowsVerbatimArguments: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> win下</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn(</span><br><span class="line">    <span class="string">'cmd.exe'</span>,</span><br><span class="line">    [<span class="string">'/s'</span>, <span class="string">'/c'</span>, <span class="string">'edp webserver start'</span>],</span><br><span class="line">    &#123;</span><br><span class="line">        cwd: <span class="literal">null</span>,</span><br><span class="line">        env: <span class="literal">null</span>,</span><br><span class="line">        windowsVerbatimArguments: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可见spawn还是比较麻烦的。</p>
<h2 id="解决方案">解决方案</h2><p>知道上面原因了，解决方案就有几个了:  </p>
<ol>
<li>子进程的系统，不再输出日志</li>
<li>maxBuffer这个传一个足够大的参数</li>
<li>直接使用spawn，放弃使用exec</li>
</ol>
<p>我觉得最优的方案是直接使用<code>spawn</code>，解除<code>maxBuffer</code>的限制。但是实际处理中，发现直接考出<code>normalizeExecArgs</code>这个方法去处理平台问题，在win下还是有些不好用，mac下没有问题。所以暂时将<code>maxBuffer</code>设置了一个极大值，保证大家的正常使用。然后后续在优化成<code>spawn</code>方法。  </p>
<h2 id="吐槽">吐槽</h2><p>其实没有怎么理解，execFile对于spawn封装加maxBuffer的这个逻辑，而且感觉就算加了，是否也可以给一个方式，去掉maxBuffer的限制。  </p>
<p>难道是子进程的log量会影响性能？</p>
<h2 id="感想">感想</h2><p>其实在解决这个问题时，发现这个差异/坑还比较意外，因为自身对于node其实还不是很熟，这个子进程的使用其实也是在ehu中第一次遇到。  </p>
<p>感受比较多的就是有时候正对问题去学习/研究，其实效率特别高。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/15/如何在项目中实现热更新（下）/" itemprop="url">
                如何在项目中实现热更新（下）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-15T14:20:59+08:00" content="2015-12-15">
            2015-12-15
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/update03.jpg" alt="如何在项目中修改代码后实现热更新"></p>
<p>本篇文章是最后一篇，主要讲一下在浏览器端的一些实现。和浏览器热更新的细节。</p>
<p>工具源码<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a></p>
<h2 id="浏览器端依赖">浏览器端依赖</h2><p><code>socket.io</code>——浏览器端仅仅依赖socket这个去和服务端通信  </p>
<p>通信逻辑</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line">socket.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    log(getLogMsgPrefix(), <span class="string">'HotUpdate已启动！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 检测到文件改动</span></span><br><span class="line">socket.on(<span class="string">'hotUpdate'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// log(getLogMsgPrefix(), '检测到文件改动', file);</span></span><br><span class="line">    <span class="comment">// ....处理文件修改后对应热更新逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="对css/less更新的处理">对css/less更新的处理</h2><p>这个原理比较简单，页面监听到样式的修改，重新加载一次样式即可，简单的覆盖。  </p>
<p>但是存在一个潜在问题，因为样式是简单的覆盖，所以，如果修改是删除了样式，是无法生效的。</p>
<p>举例：<br>修改前：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#FFFFFF</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#E8E8E8</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#FFFFFF</span></span></span>;</span><br></pre></td></tr></table></figure>
<p>删除的<code>border</code>和<code>margin-top</code>其实是没有生效的  </p>
<p>这个也是后期需要解决的一个问题。</p>
<h2 id="对模板更新的处理">对模板更新的处理</h2><p>目前项目中使用的是tpl的模板引擎。  </p>
<p>现在就遇到一个问题，在热更新时，模板引擎其实是重复加载模板的，那么就涉及到重复加载是否后面的会覆盖前面问题。  </p>
<p>查看加载模板的源码后，发现根据配置有三个选择，<code>覆盖</code>，<code>忽略</code>和<code>报错</code>， 我们业务中使用的配置是遇到重复后会报错处理，所以我们需要在不修改业务默认属性的情况下，添加一些逻辑。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [esl-hot-update] 重新加载需要覆盖</span></span><br><span class="line"><span class="built_in">window</span>.EHU_HOT_UPDATE_OPTIONS</span><br><span class="line">&amp;&amp; <span class="built_in">window</span>.EHU_HOT_UPDATE_OPTIONS.etpl.isOverride</span><br><span class="line">&amp;&amp; (namingConflict = <span class="string">'override'</span>);</span><br><span class="line"><span class="keyword">switch</span> (namingConflict) &#123;</span><br><span class="line">    <span class="comment">/* jshint ignore:start */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'override'</span>:</span><br><span class="line">        engine.targets[name] = target;</span><br><span class="line">        context.targets.push(name);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ignore'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* jshint ignore:end */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Target exists: '</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>window.EHU_HOT_UPDATE_OPTIONS.etpl.isOverride</code>这个是修改后自己实现的控制配置修改的逻辑。  </p>
<p>然后这个文件加入到服务端的路由中，请求时替换。</p>
<h2 id="对js更新的处理">对js更新的处理</h2><p>这里逻辑比较复杂，因为需要修改底层的AMD模块加载的逻辑。  </p>
<p>js没有模板那么简单，不是直接覆盖，因为在AMD模式中，每一个文件，都是被上一个文件调用执行的结果。  </p>
<p>所以我们处理的逻辑是不仅需要重新加载修改的文件，并且递归所有直接或者间接调用他的文件，全部重新加载。  </p>
<p>所以从上面的特点可以看出，这个工具目前阶段主要适用于业务模块的开发，因为业务的依赖不会特别深，对于dep中的核心文件修改，就不是很合适，一旦文件比较底层，热跟新是重新加载的模块也会非常多。</p>
<p>另外也有很多其他的坑，还在不断优化中。  </p>
<h2 id="总结">总结</h2><p>这次实践其实就是业务中遇到的问题（系统太庞大，调试太麻烦），如何解决问题，如何把解决的思路变成一个解决方案，分享给团队。  </p>
<p>因为自己解决了，和形成一个解决方案还是有非常大的差别的，例如我们在形成方案的过程中，就尝试了很多新东西，踩了很多坑。  </p>
<p>目前还有个坑就是chrome浏览器，调试的Source资源时，如果一个资源重复加载，内存中会更新，但是对应的资源没有更新，导致断点时，映射不对（断点失效），目前暂时的解决方案是，每次请求时添加时间戳，让Source映射的资源强制更新。这个可以正常断点，但是断点没有记忆功能（坑啊，因为文件变了）。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/09/如何在项目中实现热更新（中）/" itemprop="url">
                如何在项目中实现热更新（中）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-09T22:14:30+08:00" content="2015-12-09">
            2015-12-09
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/update02.jpg" alt="如何在项目中修改代码后实现热更新"></p>
<p>上一篇文章说的是一个大体的概括，本篇主要分享一些node层面实现的细节。</p>
<p>工具源码<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a></p>
<h2 id="如何使用">如何使用</h2><blockquote>
<p>npm install -g ehu（mac下需要sudo，windows下需要管理员权限）  </p>
<p>在原来执行edp webserver start命令的路径 执行 ehu（不再需要执行 edp webserver start）  </p>
<p>原来端口号8848修改为8844（原8848依旧可以使用，但不支持热更新）</p>
</blockquote>
<p>首先使用的方式很简单，为此特意将工具打包到npm上，以后就算有升级，仅仅需要大家update即可。  </p>
<p>另外从使用角度，也尽量集成化（一句命令行即可），避免为了这个工具的使用而做太多额外的事情。</p>
<h2 id="依赖的框架">依赖的框架</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"async"</span>: <span class="string">"^1.5.0"</span>,</span><br><span class="line">    <span class="string">"commander"</span>: <span class="string">"^2.9.0"</span>,</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"^4.13.3"</span>,</span><br><span class="line">    <span class="string">"express-http-proxy"</span>: <span class="string">"^0.6.0"</span>,</span><br><span class="line">    <span class="string">"lodash"</span>: <span class="string">"^3.10.1"</span>,</span><br><span class="line">    <span class="string">"socket.io"</span>: <span class="string">"^1.3.7"</span>,</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"^0.16.0"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>几个必要的<br><code>watch</code>——监听文件变化<br><code>socket.io</code>——和浏览器的实时通讯<br><code>express</code>——搭建一个服务<br><code>express-http-proxy</code>——代理<br><code>commander</code>——便于自己写node命令  </p>
<p>工具类：<br><code>async</code> 和 <code>lodash</code> </p>
<h2 id="框架的思想">框架的思想</h2><p>先看看昨天对于这个工具提出的几个要求</p>
<blockquote>
<ol>
<li>esl必然是需要修改的，但是如何对开发人员透明？首先是不能让大家都做这种修改。</li>
<li>页面中也必须加入socket.io支持，那么我们如何在不影响其他人员开发的情况下加入？</li>
<li>我们做的属于beta版本，如何选择性的使用？ehu工具和以前的开发模式随意切换？</li>
<li>安装方便，能否只是作为一个工具，即插即用，不需要繁琐的配置？</li>
</ol>
</blockquote>
<p>对于1和2，我们其实是需要修改/添加一些代码的，但是代码都不希望提交到项目的开发环境，因为这些代码生成环境完全不需要。  </p>
<p>所以我们的解决方案是：拦截，改写（偷梁换柱）   </p>
<p>举个例子，当我们需要对esl做一些改造时，我们处理方式是当路由指向esl.js时，我们换成另外一个esl-ehu.js(esl-ehu.js是对esl.js改造后的)返回去，这样就对开发环境的代码透明了。  </p>
<p>socket.io的支持也是同理，我们可以在返回html时，改写html的代码，加入对于socket.io的引入。  </p>
<p>上面的思路其实来源于之前项目构建打包。</p>
<p>对于3，我们希望在使用工具时，任然能很快切换到以前模式，这样做兼容的目的是希望工具更有竞争力，能吸引大家使用。 </p>
<p>我们的解决方案是：内部实现一个子线程，端口号依然是以前的，而且访问这个端口，就绕过了这个工具。  </p>
<p>对于子线程child_process，我们还遇到一个问题，就是子线程跑系统的时候，经常挂掉，今天刚刚找到一个解决方案，后面会单开一个文章讲这个坑。  </p>
<p>对于4，其实就是使用npm方式</p>
<h2 id="技术细节">技术细节</h2><p>第一步：搭建一个新服务作为底层，去托管住我们现在edp服务，新服务上有一个路由配置，对于我们需要处理的，拦截。对于不用处理的直接代理给edp</p>
<p>代码参考</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mid = express();</span><br><span class="line">mid.all(<span class="string">'*'</span>, httpProxy(config.defaultServer, &#123;</span><br><span class="line">    <span class="comment">// 先走特殊规则，否则就代理到默认web server</span></span><br><span class="line">    filter: <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !ruleRoute(req, res);</span><br><span class="line">    &#125;,</span><br><span class="line">    forwardPath: <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> URL.parse(req.url).path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 由express-http-proxy托管路由</span></span><br><span class="line">app.<span class="keyword">use</span>(<span class="string">'/'</span>, mid);</span><br></pre></td></tr></table></figure>
<p><code>ruleRoute</code>就是一些拦截处理</p>
<p>在此之前，启动下子进程</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> child = <span class="keyword">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="built_in">var</span> cli = child<span class="built_in">.</span>exec(defaultServerCLI);</span><br><span class="line">cli<span class="built_in">.</span>stdout<span class="built_in">.</span><span class="keyword">on</span>(<span class="string">'data'</span>, function (<span class="keyword">log</span>) &#123;</span><br><span class="line">    <span class="subst">!</span>isServerStarted <span class="subst">&amp;&amp;</span> (cb(<span class="built_in">null</span>, <span class="keyword">log</span>));</span><br><span class="line">    isServerStarted <span class="subst">&amp;&amp;</span> console<span class="built_in">.</span><span class="keyword">log</span>(<span class="keyword">log</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此处有坑，后面单开文章描述</p>
<p>第二步： 因为上面拦截后的返回的文件已经支持socket.io，esl等底层已经修改了，所以下面是需要去监听文件通知浏览器做对应处理。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 启动socket.<span class="built_in">io</span>服务</span><br><span class="line"><span class="built_in">io</span> = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br><span class="line"><span class="built_in">io</span>.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(socket)</span></span> &#123;</span><br><span class="line">    socket.emit(<span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// 监视文件改动</span><br><span class="line">initWatch();</span><br></pre></td></tr></table></figure>
<p>第三步： 做一些集成工作</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">program</span></span><br><span class="line">    .version(<span class="string">'0.0.6'</span>)</span><br><span class="line">    .usage(<span class="string">'[options]'</span>)</span><br><span class="line">    .option(<span class="string">'-p, --port &lt;n&gt;'</span>, <span class="string">'Set the port'</span>, setPort)</span><br><span class="line">    .option(<span class="string">'-n, --noServerCLI'</span>, <span class="string">'...'</span>, <span class="built_in">no</span>ServerCLI)</span><br><span class="line">    .parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>集成到node命令中</p>
<p>第四步： 默认配置</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="module"><span class="keyword">module</span>.exports = </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的服务器</span></span><br><span class="line">    defaultServer: <span class="string">'http://127.0.0.1:8848'</span>,</span><br><span class="line">    <span class="comment">// 默认的服务器启动命令</span></span><br><span class="line">    defaultServerCLI: <span class="string">'edp webserver start'</span>,</span><br><span class="line">    <span class="comment">// 从服务器根目录到需要监控的文件夹中间path</span></span><br><span class="line">    baseDir: <span class="string">'nirvana-workspace'</span>,</span><br><span class="line">    <span class="comment">// hot update 需要watch的文件夹（不包括baseDir）</span></span><br><span class="line">    watchDirs: <span class="string">'src'</span>,</span><br><span class="line">    <span class="comment">// 入口文件（不包括baseDir）</span></span><br><span class="line">    indexHTML: <span class="string">'main.html'</span>,</span><br><span class="line">    <span class="comment">// ehu启动端口号（不可与默认的服务器端口号冲突）</span></span><br><span class="line">    port: <span class="number">8844</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>源码中有很多逻辑是处理配置的</p>
<h2 id="最后一篇预告">最后一篇预告</h2><p>分享一下esl等基础框架的改造，和浏览器监听到通信后的修改。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/07/如何在项目中实现热更新（上）/" itemprop="url">
                如何在项目中实现热更新（上）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-07T22:01:33+08:00" content="2015-12-07">
            2015-12-07
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/update.jpg" alt="如何在项目中修改代码后实现热更新"></p>
<p>这个是组内一位同学在平时开发中，发现调试不便，为团队开发的热更新工具。很厉害，文章中的技术实现内容也是我了解了他的具体实现思路后，整理出来的。</p>
<p>工具源码<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a></p>
<h2 id="热更新是什么">热更新是什么</h2><p>热更新就是当你在开发环境修改代码后，不用刷新整个页面即可看到修改后的效果。</p>
<p>如果你的项目中使用了webpack的话，你会很幸运，借助webpack-dev-server插件可以实现项目的热更新。</p>
<h2 id="解决的问题">解决的问题</h2><p>对于大型的系统级别项目会有下面几个特点</p>
<ol>
<li>模块化（AMD）模式的广泛使用后，开发环境散文件特别多，很容易上百，一不小心还能上千</li>
<li>初始化的内容特别多，各种底层库，ui库等等</li>
</ol>
<p>这两个特点直接导致每次调试后，刷新会很慢。如果初始化的js达到上千的数量级，每一次重新刷新都是5s，10s，甚至20s的等待。</p>
<p>而热更新的目的就是为了在一定程度上减少这5s，10s，甚20s的浪费。</p>
<h2 id="遇到的问题">遇到的问题</h2><ol>
<li>我们使用的是百度自己的开发环境工具edp，首先他不支持热更新</li>
<li>我们使用的AMD实践也是百度自己的esl，而且即使是requirejs也暂时没有找到对应的热更新策略，假如requirejs有对应的，我们也无法直接使用</li>
</ol>
<p>所以最终的结论是我们自己去实现一个基于我们自己业务的。这样我们考虑的面不用太广，并且解决方案的更有针对性，即面向我们现有的业务框架。最重要的是可以尝试修改底层框架做配合。</p>
<p>等待路踩通了，我们再去考虑普适性。</p>
<h2 id="解决的思路">解决的思路</h2><p>从ehu/package.json 这个文件中，我们就可以看出一些具体的思路  </p>
<ol>
<li>需要一个watch功能，即能够监听到文件的修改</li>
<li>socket.io通知浏览器处理文件的改变</li>
<li>修改esl这个文件，达到能够实时更新的效果</li>
</ol>
<p>当时最简单的考虑，就是文件改变了后，能够通知浏览器，浏览器去重新load这个文件并且执行一次。这个时候再重新去打开这个模块或者功能后，会发现新load的代码在执行后会覆盖上一次的。</p>
<p>所以当时的我的第一直觉是，esl重复require时，如果后面一次会覆盖前面的，那么可以通过简单的覆盖思路去尝试，结果发现覆盖不了。经过验证，发现是esl内部维护了一个map，即require过的模块会存起来。我们如果希望更新这个模块，只能将map中的对应模块名删除。（后面会详细讲述esl的改造）</p>
<h2 id="对于工具的要求">对于工具的要求</h2><p>对应这个工具，我当时也提出了几个要求</p>
<ol>
<li>esl必然是需要修改的，但是如何对开发人员透明？首先是不能让大家都做这种修改。</li>
<li>页面中也必须加入socket.io支持，那么我们如何在不影响其他人员开发的情况下加入？</li>
<li>我们做的属于beta版本，如何选择性的使用？ehu工具和以前的开发模式随意切换？</li>
<li>安装方便，能否只是作为一个工具，即插即用，不需要繁琐的配置？</li>
</ol>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/02/ES6引入前需要解决的问题/" itemprop="url">
                ES6引入前需要解决的问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-02T19:35:03+08:00" content="2015-12-02">
            2015-12-02
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/es6.png" alt="ES6引入前需要解决的问题"></p>
<p>最近项目中的一个模块正式引入的ES6，由于是引入新技术，也遇到了一些问题，下面分享下整个引入流程</p>
<h2 id="为什么要引入ES6">为什么要引入ES6</h2><p>最近在看一些前端解决方案的文章，ES6越来越多的出现在前端方案中。</p>
<p>ES6由于浏览器不支持，在使用上也是和CoffeeScript和TypeScript一样，都需要compile-to-JS。  </p>
<p>理由一：<br>符合未来趋势，angular2就是使用TypeScript实现；<br>react native 也是可以直接使用es6的语法；</p>
<p>理由二：<br>提高开发效率（待考证）；</p>
<p>理由三：<br>减少代码量、提高可读性等  </p>
<p>但我觉得不仅仅如此，应该会有更多优势。所以需要亲自验证。</p>
<h2 id="引入前考虑最多的事情">引入前考虑最多的事情</h2><p>从个人的角度，趋势这个东西说不准，减少代码量、提高可读性等这些其实都可以通过规范来完成。  </p>
<p>我个人最看重的是效率这块，是否能够真正的提高团队开发效率。  </p>
<p>另外在一片文章中看到说facebook.com 都使用了ES6 + babel complile，我心里也安稳了一些。  </p>
<p>考虑的第二点就是是否会给整个系统引入技术债务，由于这个是新技术的引入，和之前框架没有任何重叠，而且引入也是选择性的（提供一种可用的环境）。如果未来有较大的升级，我们可以修改compile-to-JS做适配和转换。</p>
<p>最后一个问题是我们项目使用的不是grunt这种，有直接的解决方案，引入可能会有风险。不过庆幸的是，我们发现我们使用的edp已经支持了。其实我们开始已经想好了如果不支持，自己会扩展一些插件去支持。</p>
<h2 id="技术方案">技术方案</h2><p>ES6 + babel</p>
<h2 id="需要解决的问题">需要解决的问题</h2><ol>
<li>开发环境下的浏览器不支持ES6？</li>
<li>使用babel转换的代码，调试不方便？</li>
<li>线上环境的代码打包编译怎么处理？</li>
<li>ES6的新特性哪些适合使用？</li>
<li>ES6的新特性是否通过babel转换后还有兼容问题？</li>
<li>开发效率是否会有提高？</li>
<li>编译器高亮支持？</li>
</ol>
<h2 id="下面挨个解决问题">下面挨个解决问题</h2><p>想到一句话  </p>
<blockquote>
<p>你可以坐以待毙，也可以立刻动手解决问题，解决一个再解决一个，解决了所有问题，你就活下来可以回家了</p>
</blockquote>
<p>来自《火星救援》  </p>
<p><strong>开发环境下的浏览器不支持ES6？</strong><br>这个容易，使用babel。</p>
<p><strong>使用babel转换的代码，调试不方便？</strong><br>确定了sourceMap的方式解决，但是开始没有认真看babel文档，绕了个圈子，最后发现babel有个属性</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceMaps：both</span><br><span class="line">filename： pathname.<span class="function"><span class="title">replace</span><span class="params">(/\.(\w+)</span></span>$/, <span class="string">'.raw.$1'</span>)</span><br></pre></td></tr></table></figure>
<p>传入这个参数sourceMaps传入表示启用；<br>filename是编译前对应的文件,这里必须给一个和处理的文件名不一样的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.<span class="function"><span class="title">transform</span><span class="params">(code, options)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>线上环境的代码打包编译怎么处理？</strong><br>在构建的流程中，加入一个babel-processor的流程即可，加入的时机需要是在模块压缩合并前，其实就是越早越好。  </p>
<p><strong>ES6的新特性哪些适合使用？</strong><br>我们参考<br><a href="http://efe.baidu.com/blog/es6-develop-overview/" target="_blank" rel="external">使用ES6进行开发的思考</a>  </p>
<blockquote>
<p>arrows    ★★★<br>classes    ★★★<br>enhanced object literals    ★★★<br>template strings    ★★★<br>destructuring    ★★<br>default + rest + spread    ★★★<br>let + const    ★★★<br>iterators + for..of    ★★<br>generators    ★<br>unicode    ☆<br>modules    ★★<br>module loaders    ☆<br>map + set + weakmap + weakset    ★★<br>proxies    ☆<br>symbols    ★<br>subclassable built-ins    ☆<br>promises    ★★★<br>math + number + string + array + object APIs   ★★★<br>binary and octal literals    ★<br>reflect api    ☆<br>tail calls    ★★  </p>
</blockquote>
<p>文章推荐的新特性，仅使用三星的。  </p>
<p>另外推荐阅读<a href="http://www.csdn.net/tag/%E6%8E%A2%E7%A7%98es6/news" target="_blank" rel="external">探秘ES6</a> 系列</p>
<p><strong>ES6的新特性是否通过babel转换后还有兼容问题？</strong><br>团队中又同学正在验证，我们验证的环境是IE9+,ff,chrome，我们最终会使用三星特性加上兼容性ok的。</p>
<p><strong>开发效率是否会有提高？</strong><br>后面会通过做一个小的新需求，或者重构一个小模块去验证。  </p>
<p><strong>编译器高亮支持？</strong><br>sublime Text 下面<br><a href="https://github.com/babel/babel-sublime" target="_blank" rel="external">https://github.com/babel/babel-sublime</a><br>或者<br><a href="https://github.com/voronianski/oceanic-next-color-scheme" target="_blank" rel="external">https://github.com/voronianski/oceanic-next-color-scheme</a></p>
<p>其实问题就这么多，比想象中简单许多，未来可能还有坑，但是至少我们开始尝试了。</p>
<h2 id="红利">红利</h2><ol>
<li>语法有问题时，编译报错——语法检查</li>
<li>面向未来——未来很多源码都是预编译类型</li>
<li>开阔前端思路</li>
<li>能读懂以后牛逼框架的源码， angular2 使用typescript</li>
</ol>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/28/sourceMap初探索/" itemprop="url">
                sourceMap初探索
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-28T19:40:55+08:00" content="2015-11-28">
            2015-11-28
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/sourceMap.png" alt="sourceMap初探索"></p>
<h2 id="sourceMap的偶遇">sourceMap的偶遇</h2><p>接触到sourceMap，其实是在调研ES6时发现的。  </p>
<p>在调研ES6引入生产环境的可能性，初步觉得引入项目时需要解决的几个问题：  </p>
<ol>
<li>上线时的打包构建问题</li>
<li>开发环境编译问题，目前chrome都不兼容es6</li>
<li>解决了开发环境编译后，调试问题——开发的代码和浏览器跑的代码不一样  </li>
<li>其他没有考虑到的问题等等</li>
</ol>
<p>其中sourceMap就是在调研第三个问题时，发现的。<br>想想如果在debug时浏览器显示的是编译后的代码，这个对于调试其实是致命的打击。  </p>
<p>而通过目前的调研，发现sourceMap就是这个问题的解决方案。 </p>
<h2 id="sourceMap是什么">sourceMap是什么</h2><p>请大家直接看阮一峰的文章<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">JavaScript Source Map 详解</a>  </p>
<p>原理我简单的理解就是通过map文件产出一个映射关系，将编译后的代码映射到编译前的，然后debug时，浏览器解析的是编译后的，但是呈现给我们的是映射前的开发代码。</p>
<h2 id="sourceMap曾经被忽视">sourceMap曾经被忽视</h2><p>在网上找的一些介绍Source Map的文章，发现Source Map主要是解决一些代码压缩混淆后不好调试的问题。 </p>
<p>举个例子，jquery-min调试时非常不方便，但是加上Source Map，可以直接在浏览器中调试jquery压缩前的。  </p>
<p>但是真正在开发环境，可能将jquery-min换成jquery，大家觉得会更加方便，无需那么麻烦处理，所以这也是可能没有流行起来的原因。  </p>
<h2 id="sourceMap为什么又会被重视">sourceMap为什么又会被重视</h2><p>直接拿我遇到的问题说明，ES6语法浏览器执行不了怎么办?</p>
<p>使用babel，ok，babel可以编译成js给浏览器执行。这个时候，编译后的代码必然会和我们开发时的不一样。  </p>
<p>这时如果我们希望还和以前使用js一样去调试，怎么办？</p>
<p>只能利用Source Map这种，产生一种映射关系，去将开发中的代码映射到debug工具中。  </p>
<p>除了es6，另外一个被看好的typescript（angulejs2使用typescript实现），它也同样存在这个问题（目前没有调研它的调试方式）。  </p>
<p>可以预见，这种加入一种编译方式去写js可能是未来的一种趋势。<br>小小跑题一下，为什么个人觉得是一种趋势，编译做的越牛逼，开发的代码就会越简单，能让开发人员抓住与业务，兼容，适配，自适应的坑都交接编译去解决，大大的提高了工程效率。  </p>
<h2 id="sourceMap使用参考">sourceMap使用参考</h2><p>大家看看下面这个链接（需要翻墙）：  </p>
<p><a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank" rel="external">http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/</a></p>
<p>里面还有例子是将java编译成js，然后在chrome中使用sourceMap直接debug java的代码。  </p>
<h2 id="我对sourceMap的了解">我对sourceMap的了解</h2><p>由于最近比较忙，这篇文章只是初步探索，了解的非常非常浅，没有什么干货，后面有一定成果后还会继续更新sourceMap其他方面。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/21/敏捷开发工具推荐/" itemprop="url">
                敏捷开发工具推荐
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-21T15:27:33+08:00" content="2015-11-21">
            2015-11-21
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>推荐工具地址<br><a href="http://cafe.baidu.com/" target="_blank" rel="external">http://cafe.baidu.com/</a>  </p>
<p>这个工具百度很多团队都在使用，现在开发了一版对外的，我觉得很赞。   </p>
<p>我觉得工具的核心功能就是很好的解决项目延期的问题。</p>
<p>我个人对于这个工具的理解。</p>
<h2 id="任务拆解">任务拆解</h2><p>针对大型项目，任务拆解是非常重要的一块，如果没有合适的拆解，很多问题都会积压到项目deadline才集中暴露，如果暴露的问题太多或者问题难度太大，都会直接导致整个项目的延期。  </p>
<p><strong>如何拆解项目：</strong><br>我们的经验是分为story和task，两个层级。  </p>
<p><strong>针对story的定义</strong><br>就是项目中每一个具体的产品上可感知的功能点，所以story由pm拆分比较合适  </p>
<p>对应story的大小<br>从项目上看，是可以独立验证的一个功能，例如一个图片上传组件，一个筛选区域的完整筛选功能。<br>从时间上面看，最好不要超过10天。  </p>
<p><strong>针对task的定义</strong><br>就是每个story中具体的开发任务，这个是由开发人员自己拆分<br>story的拆分个人经验最好是从时间上面去拆分，每个任务最好都是1，2天的工作量，最多不要超过3天。  </p>
<p>拆分任务的另外一个红利就是，对于任务拆分的越细，对于需求的理解就越透，很多问题你会发现在拆分时就能暴露出来。<br>当你将一个20天，30天的任务能细化到每一天做什么时，你会发现，你项目的整体设计就已经出来了。  </p>
<p>拆分还有一个红利，当你将任务拆分的特别细致时，越不容易被质疑。这个和确定预算的道理差不多。</p>
<h2 id="每天任务状态跟踪">每天任务状态跟踪</h2><p>下面是工具里面的任务跟踪状态图  </p>
<p><img src="/img/res/4/track.png" alt="前端修炼"></p>
<p>对于团队之间的合作，每天的任务跟踪可能不用特别细致，跟踪story整体状态即可。<br>但是对于团队内部，任务进度是务必跟踪到task的，这样能让每一个风险点最快的暴露。<br>每天都及时确认下当前task的状态，没有问题，大家正常进度开发，出现问题及时解决问题。</p>
<h2 id="问题及时暴露">问题及时暴露</h2><p>对于每个项目，特别是时间周期比较长的项目，避免不了会有一些坑，以及一些当初没有预料到的风险。  </p>
<p>我们决定不了会遇到什么样的风险，但是我们可以决定一个处理风险的方式。<br>是风险全部挤压到项目后期集中爆发还是将风险分散于开发的日常任务中？</p>
<h2 id="多人合作">多人合作</h2><p>这个工具可以多人合作，不能能够了解到自己的状态，还能同步了解合作方的状态。</p>
<h2 id="疑问">疑问</h2><p>拆分其实就需要花费一定的工作量，那么前期花这么多时间是否值得？<br>如果平常项目经常遇到delay，或者平常项目经常出现到了项目末期都是出于一种赶工的状态。<br>我觉得可以考虑引入这种模式。  </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/16/听厂里高工分享有感/" itemprop="url">
                听厂里高工分享有感
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-16T19:14:44+08:00" content="2015-11-16">
            2015-11-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>上周听了厂里高工（T10）的分享，对于下面两点（技术深度和广度、解决问题的方法）有些感触。</p>
<h2 id="技术深度和广度">技术深度和广度</h2><p>当我们去扩展我们技术的广度时，我们千万不要成为了一个<code>杂家</code>，什么都学，什么都会，但是确达不到精通。  </p>
<p>我们需要的一种能力是，深入的研究一门技术，并且能够抽象出一种学习的方法出来，然后能用这种方法快速适应各种其他技术或者新技术。  </p>
<p>当你在某个领域真正深入到一种程度，你会发现再学习其他东西没有那么复杂了，会感觉很多东西非常相似。  </p>
<p>所以请沉下心来，将一门技术深入下去。</p>
<h2 id="解决问题的方法/态度">解决问题的方法/态度</h2><p>大神提到他之前遇到的大神处理问题的方法，很简单  </p>
<p><strong>直接针对问题直接去解决问题</strong>  </p>
<p>想想我们处理问题的方式：<br>最简单的处理方式：绕过问题，回避出问题的地方<br>技巧点的处理方式：通过一些hack的手段间接的去修复问题<br>牛逼的处理方式： 直接针对问题，找到出问题的根源去解决 </p>
<p>平常是可以通过对于解决问题的方法来看出技术实力的。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/img/weixin.jpg" alt="Yao Tang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Yao Tang</p>
        </div>
        <p class="site-description motion-element" itemprop="description">前端修炼之路</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yao Tang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
