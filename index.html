<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="前端修炼之路" />



  <meta name="keywords" content="前端,javascript" />





  <link rel="shorticon icon" type="image/x-icon" href="/img/favicon.ico?v=0.4.5.1" />


<meta name="description" content="前端修炼之路">
<meta property="og:type" content="website">
<meta property="og:title" content="Yao's 前端修炼之路">
<meta property="og:url" content="http://tangguangyao.github.io/index.html">
<meta property="og:site_name" content="Yao's 前端修炼之路">
<meta property="og:description" content="前端修炼之路">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yao's 前端修炼之路">
<meta name="twitter:description" content="前端修炼之路">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Yao's 前端修炼之路 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?e35a2df9e882a5f8ed351d0f022fa689";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Yao's 前端修炼之路</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/03/09/两个独立系统间的模块互相调用/" itemprop="url">
                两个独立系统间的模块互相调用
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-03-09T21:35:28+08:00" content="2016-03-09">
            2016-03-09
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>面试时经常问的一个问题是，你最近或者做过的项目中挑战最大的内容，然后顺着其中的技术点挖一些更深入的内容，看看候选人了解多少，理解程度。  </p>
<p>然后突然想了想我做的有什么难度比较大的项目，可以给大家分享下。  </p>
<p>今天介绍下我一年前完成的一个两个独立系统的模块打通过程，换句话说就是A系统可以直接使用B系统的业务模块。   </p>
<h2 id="背景介绍">背景介绍</h2><p>A系统是一个古老的系统，B系统是一个新做的系统，（原本是希望A系统的功能全部迁移到B系统上的，但是由于各种原因搁置了）当时结果导致两个系统在同时使用和升级。  </p>
<p>随着业务的开发，很多需求在A和B系统之间产生了关联性，例如B系统上线了一个新产品，然后为了增加入口和使用量，需要在A系统上可以直接调用新产品的某个功能。<br>直观的解决方案是A系统上面复制粘贴一份B系统上面这个产品的功能，但是问题就来了，未来维护起来怎么办，同时维护两份代码？以后这样的需求多了怎么办，重复代码越来越多？  </p>
<p>另外一个解决办法就是A,B两个系统间的融合。当然这样评估的一个前提是A和B虽然是两个系统，但是大家开发模式，底层依赖还是相似的。</p>
<h2 id="需求分析">需求分析</h2><p><img src="/img/res/contact1.png" alt="需求拆解"></p>
<p>上面是这两个系统的基本架构，拆分成线上线下两个部分。  </p>
<p><code>A</code>网站有两个业务模块<code>A1</code>和<code>A2</code>。</p>
<p><code>B</code>网站有三个业务模块，<code>B1</code>,<code>B2</code>,<code>B3</code>。  </p>
<p>现在的需求是B1这个模块不仅能在B系统中运行，而且可以共享到A系统中。</p>
<p>目标如下图：  </p>
<p><img src="/img/res/contact2.png" alt="需求拆解"></p>
<p>那么问题来了： </p>
<p><img src="/img/res/contact3.png" alt="需求拆解"></p>
<h3 id="问题一">问题一</h3><p>支持业务代码的底层dep和common不一样。<br>随着时间的推移，dep依赖第一个是引入的库有些差别，第二个更加严重是是大部分库的版本已经不一样了。   </p>
<p>业务模块的底层就像是生态环境，如果生态环境差别越大，那么这两个生态融合在一起的困难也就越大。  </p>
<h3 id="问题二">问题二</h3><p>B1这个模块在A系统中调用时，如何找对路径。<br>举个例子：<br>B系统中有一个 <code>module/b/c/d.js</code>;<br>B1中require了一个 <code>module/b/c/d</code>，在B系统中是可以正确访问到的。  </p>
<p>但是如果在A系统中调用到B1的require的<code>module/b/c/d</code>。它是会找到A系统中的<code>module/b/c/d.js</code>;  </p>
<p>这只是其中的一个例子，由于系统中的AMD模式，路径的寻找也是一个坑点。  </p>
<p>当然对于上面的问题可以通过<code>map</code>方式（esl.js中有个map，require.js应该也有对应的）。当时是用过另外一种方式解决的。</p>
<h3 id="问题三">问题三</h3><p>编译两个问题，<br>一是路径问题，当时坑我最深的。<br>二是业务模块独立打包，A系统中应该是仅仅需要B1这个业务，而不是所有B系统中的代码。  </p>
<h3 id="问题四">问题四</h3><p>如何对开发人员透明，这个很关键。如果系统融合了，一线的开发人员需要为此做很多事情，就比较失败了。  </p>
<p>所以整个调用过程如何让开发无感知，B系统中正常开发一个模块，A系统通过一个api就能直接使用了，也不需要区分线上线下。</p>
<h2 id="具体步骤">具体步骤</h2><p>主要问题抛出了，后面就是看如何一一对应的解决问题了。  </p>
<p>当然了上面介绍的以外，还有很多细节问题，例如融合后样式冲突这种很多细节上面的坑。只是这些没有上面四个问题那么严重。  </p>
<h3 id="第一步，底层打平">第一步，底层打平</h3><ol>
<li>dep打平（1）A系统中补充B系统中新增的库，相对简单</li>
<li>dep打平（2）A和B系统中有差异的库，都升级到同样版本，这个非常坑，由于很多使用的是公司或者部门内部的库，升级不想外部jquery一样对开发透明，他们的升级绝对不是透明的，哪怕是百度最火的echart。所以解决升级库的兼容问题是一个工作量很大的活。  </li>
<li>common基础依赖合并。找出不同内容互补，然后相同又冲突的内容，修改打补丁方式，虽然有坑，但是经理了dep的升级，觉得还ok。</li>
</ol>
<p>完成上面三步后的一个期望的成果是，B1模块以及依赖的内容可以直接复制到A系统中，在A里面可以直接调用打开。  </p>
<p>注意一些细节就是初始化是否相同，A和B如果初始化不一样，可能在A系统调用B1时，B1有些内容缺少初始化过程。（这种就是属于细节上的坑了）</p>
<h3 id="第二部，处理path路径">第二部，处理path路径</h3><p>当时处理思路比较简单，B1模块前面统一加上B1这个前缀，这样就能够在require时找到指定的路径了。  </p>
<p>这个地方的难点在于打包编译，因为破坏了默认的打包规则，而且根据一些打包的扩展配置也无法达到期望。  </p>
<p>当时解决的方式是仔细的研究了打包编译流程，很大程度上面重写了或者说hack了默认的打包规则。  </p>
<p>其实打包编译都研究到这里了，也就顺便把问题三解决了。当时的对于打包的研究已经可以安装需要随意打包了。 </p>
<p>这里的预期效果就是B1模块在B自己的系统中，A中可以调用打开了 </p>
<h3 id="第三部，对开发人员透明">第三部，对开发人员透明</h3><p>完成上面步骤后，有一个遗留问题是，线上打开的方式和线下打开的方式不一样，对于开发人员非常不友好。  </p>
<p>所以这一步应该是优化过程，让这个功能更加完善，所以写了一个简单的api，开发人员只需要调用api即可，不需要考虑线上和线下逻辑。这个复杂的逻辑包含到了api中处理。  </p>
<h2 id="项目难点">项目难点</h2><p>我个人认为这个项目的难点：  </p>
<ol>
<li>对于两个系统的架构要非常熟悉</li>
<li>对于打包编译需要非常熟悉，因为一旦涉及到线上和线下，编译就是必须要了解的内容</li>
<li>对于系统底层代码要熟悉，因为在升级dep过程中，很多版本兼容bug必须要定位到底层代码中</li>
<li>对于AMD需要熟悉，当时定位甚至发现了esl.js和require.js在某种场景的细微区别</li>
</ol>
<h2 id="目前状态">目前状态</h2><p>在最近一年中，A和B两个系统以及融合在一起了。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/03/01/我是如何优化网站首页性能的/" itemprop="url">
                我是如何优化网站首页性能的
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-03-01T13:50:39+08:00" content="2016-03-01">
            2016-03-01
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/fix.jpg" alt="我是如何优化网站首页性能的"></p>
<p>最近接到一个任务，首页性能优化。  </p>
<p>目标：95分位值下  </p>
<ol>
<li>看到页面框架主体内容6s（优化前10s左右），优化提升40%</li>
<li>看到操作详细内容9s（优化前12s左右），优化提升25%。  </li>
</ol>
<p>侧面看出我们系统的庞大程度吧，这个不值得骄傲，项目比较悠久，历史包袱比较沉重，后面计划node同构方式去重构，但是现阶段需要一个低成本，短时间的方案去提高现有性能作为过渡。</p>
<h2 id="95分位值解释">95分位值解释</h2><p>95分位值目前是我们看性能指标的一个重要参考点。  </p>
<p>举例：收集用户打开的时间，从快到慢排列，比如是100个用户数据，95分位值就是取出第95个用户的数据做统计。 50分位值就是第50个人的数据。</p>
<p>为什么是95%，因为跟进高T的优化经验，95分位值的数据取点最能放大问题。50,80的取点暴露的问题不明显。 </p>
<p>当我把最慢的那一批人的性能优化好了，哪些快的自然就解决了。</p>
<h2 id="优化难点">优化难点</h2><ol>
<li>面试经常问到的页面优化点，例如图片合并，js合并，css合并，js压缩等等都已经做了。常规优化点没有什么空间可以优化。</li>
<li>代码比较老。注释上面都是12-13年的代码。</li>
<li>改动需要尽量的少，功能点不能改，时间比较紧张，QA没有人力支援，所以需要代码改动比较小的情况下（修改必须可控），不重构的情况下挖掘优化点。</li>
</ol>
<h2 id="任务拆分">任务拆分</h2><p>优化性能这种任务其实比较难制定计划，除非经验特别丰富。   </p>
<h3 id="第一步：是梳理代码">第一步：是梳理代码</h3><p>当然也不是看所有的老业务代码，看的重点是看各个模块的加载逻辑，展现逻辑，看入口即可。  </p>
<h3 id="第二部：删遗留代码">第二部：删遗留代码</h3><p>大概了解整个首页的初始化流程后，梳理了简单的逻辑后，发现第一个任务，删代码。  </p>
<p>梳理大概结构后，目测有大量下线功能的代码任然遗留在系统中，之前的下线逻辑应该是仅仅屏蔽了入口，而没有清理代码。  </p>
<p>所以我第一个具体的工作就是找出下线的业务代码并将他清理，不完全统计，清理代码量开发环境下至少5W行。 </p>
<p>清理代码好处很多： </p>
<ol>
<li>减少无用代码的初始化消耗</li>
<li>减少静态资源</li>
<li>让代码更加清晰，减少无用代码的干扰  </li>
</ol>
<p>删除无用代码其实是个脏活，吃力不讨好，删除的代码如果还有地方引用，那么删除了就是引入了一个bug。</p>
<p>删除代码这个工作又没有什么显性的收益，还费工费时。其实就是一个里子的工作，把大家看不到的地方做好。</p>
<h3 id="第三部：优化初始化逻辑">第三部：优化初始化逻辑</h3><p>尽量让不是完全依赖的ajax并行，减少串行。当前系统有两个展示模块有串行关系。梳理业务后，找出首页加载的默认逻辑，将串行调整成为并行。  </p>
<p>这里是修改代码的地方之一，修改越少越好，因为一旦修改多了，就不好控制了，就需要QA介入，那么整个项目的周期就会大大延长。</p>
<h3 id="第四部：ajax预取">第四部：ajax预取</h3><p>这个是上一个项目经验积累，在加载模块静态资源前，可以并行的请求这些模块的ajax内容。原本逻辑是，加载完毕各个模块的静态资源，然后模块内部开始加载静态资源需要的ajax。这样就避免不了静态资源的请求和静态资源里面ajax的请求形成了一个串行关系。<br>预取的一个明显优势是，ajax可以提前  </p>
<p>节省的时间 = <code>min(ajax请求时间，静态资源加载时间)</code>。</p>
<p>这里是修改的另外一个地方：同理，这个地方没有业务逻辑，所以需要和业务完全解耦着做。</p>
<h3 id="第五部：优化打包合并">第五部：优化打包合并</h3><p>打包这部分难度比较大，优化空间也相对较多。<br>这里分了两部分：  </p>
<h4 id="一：首屏不展示部分按需加载">一：首屏不展示部分按需加载</h4><p>目前看很多应该按需加载的内容全部都合并到了一起，放在首屏加载了。例如点击一个按钮出来一个操作页面弹框。其实这个弹框的代码首屏展示是完全不需要。  </p>
<p>当时注释：  </p>
<blockquote>
<p>代码加起来压缩完大概200kb左右，没必要拆的太细,如果代码达到500KB以上，再进一步考虑细拆</p>
</blockquote>
<p>实际情况是，这个部分的代码压缩混淆后达到了1.1MB（坑爹啊）。   </p>
<p>这种情况就是当初开发人员设想是美好的，后续业务开发人员没有意识或者了解到当初的规定，业务越来越多，代码也就越来越多。  </p>
<p>这种情况其实比较常见，因为打包合并这种其实是尽量对业务人员透明的，这种合并后的内容，其实在开发环境体现不出来，只有刻意的压缩代码和优化时才能注意到。  </p>
<p>容易忽视的部分就是容易出现问题的地方。</p>
<h4 id="二：_打包合并重复的部分删除">二： 打包合并重复的部分删除</h4><p>还是上面的原因，打包合并对于开发人员和开发环境透明，很长一段时间后，会发现大量打包重复，比较明显的就是底层依赖库个个文件重复引用。这种不会引发bug，但是会影响首屏静态资源的加载和静态资源的解析。</p>
<p>一和二的成果很明显：静态资源网络压缩后（gz），1.9mb优化到了1.1mb，整体提升了42%。</p>
<h4 id="三：_疑难散文件清理">三： 疑难散文件清理</h4><p>之前优化过几次散文件，由于成本比较大，遗留了一些散文件。这次就是集中处理了一下，散文件其实是比较严重的，一个散文件就会浪费一个请求。95分位值下，一个散文件可能就是100ms的影响。所以不要小看散文件对于性能的影响。</p>
<p>成果是减少5个js静态资源请求，2个css请求。</p>
<h2 id="优化感受">优化感受</h2><p>这些优化本周会上线，期待数据会比较好看。如果本周效果不是很明显，后面的优化空间其实就非常小了，暂时不考虑cdn，依赖后端这些方法，仅仅从静态资源出发。  </p>
<p>优化其实就是一个没有那么明确计划的任务，往往有可能对着页面一遍一遍看加载流程或者把源代码挨个扫一遍找找感觉，一个突发奇想，一个奇淫技巧，一个业务展示效果的调整就能达到。</p>
<p>后续看看是否达标，性能不达标的话，还会有《我是如何优化网站首页性能的（番外篇）》。/(ㄒoㄒ)/~~</p>
<h2 id="优化感受2">优化感受2</h2><p>优化就是细节完善，举个例子：  </p>
<ol>
<li>有时一个js散文件可能多消耗50ms，但是一旦出现10个，20个影响就叠加起来了。</li>
<li>一个底层库被重复打包了，可能多了几千行，静态资源增加了几k，加载上可能就是几ms，加上与解析几ms。但是一旦重复的静态资源多了，问题就来了。上万行，上百K的资源都是拖慢系统的根源。难以想象我这次粗滤的清理了一下，清理了0.6MB的资源。  </li>
</ol>
<p>优化没有止境，这一版上线后，肯定还有很多遗留的地方，后续看看效果，继续优化。</p>
<p>ps:最后发现自己整理完这么多，也没有做什么，感觉后面还需努力</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/28/react融合进系统的体验/" itemprop="url">
                react融合进系统的体验
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-02-28T22:22:59+08:00" content="2016-02-28">
            2016-02-28
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/react.jpg" alt="react融合进系统的体验"></p>
<h2 id="引入的背景">引入的背景</h2><p>在一个庞大的商业系统中引入react这种数据驱动的模式。<br>希望能够一点点重构去替换以前的模块，逐步的将系统重要部分底层框架替换成react。</p>
<h2 id="同事实践的心得">同事实践的心得</h2><p>以下内容都摘自同事使用后的一些感想</p>
<p>心得一</p>
<blockquote>
<p>从过程化开发向面向数据的开发转化。后者要求开发者对数据结构和算法和业务需求本身要有理解。React开发的核心是设计一套数据结构使其既方便业务用户界面的展示又能方便的实现业务功能——表现为一组操作数据结构的算法。这与传统的前端开发很不一样，偏激一点的说，相比以前用$搬弄DOM节点，我觉得这样的前端开发更“严肃”了。我希望能够推动团队迎接，适应，实现这个变化，这对于一个技术人员，而不仅仅是前端技术人员都是有益的。</p>
</blockquote>
<p>心得二</p>
<blockquote>
<p>1．React单向数据流原则是核心中的核心，即整个系统中只存在自上至下的数据流，反向数据流通过绑定自动完成，不存在兄弟间横向数据流。</p>
<p>2．控制数据流属于最强的开发规范，必定会给开发业务的同学带来巨大的思维挑战，从系统整体质量和维护性来看，必须牺牲业务开发的编程自由度。目前就是自由度太高，导致出现五花八门的业务实现，代码根本没法看。</p>
</blockquote>
<p>心得三</p>
<blockquote>
<p>其实之前我们也是数据驱动视图的，生命周期时用初始化数据渲染了视图，自然这时有了一层数据到视图的映射逻辑关系。数据改变之后绑定视图映射关系会写在model onchange handler中。</p>
<p>这样会有一些问题：</p>
<p>1.数据到设图的映射逻辑关系可能写了两遍，而且会发散在template, action, view等各个地方</p>
<p>2.初始化时数据和视图的关系是同步的，但是初始化之后这两者就可能就不一致，很可能handler没写用jquery直接操作DOM了。</p>
<p>初级阶段觉得React的好处是，把映射关系收敛到render方法中，有一层封装让我们直接操作DOM变得更难。数据如果在任何时候都能表达视图，是有很多事情可以想象的。</p>
</blockquote>
<p>心得四</p>
<blockquote>
<p>我们需要在React方面思考的技术问题，有下面这些点：</p>
<p>UI组件应当有稳定一致的开发规范。</p>
<p>UI组件应当有充分的UT 。（并尝试是否可以为业务组件加UT）</p>
<p>UI组件乃至业务组件内的数据结构是否应该有一个统一的模式（如immutable或者更轻量的模式），使得对于数据结构的任意位置的修改，都可以有事件冒出做一些统一的处理。</p>
<p>多个兄弟的组件之间的通信有什么范式？</p>
<p>父子组件之间双向通信有什么范式？</p>
<p>目前实现了ER-React，即一个React模块对外表现为一个ER模块。未来在此基础上，将一个ER-React模块的父模块实现为React后，是要脱掉ER-React的ER，变为React-React呢？还是实现为React-ER-React呢？</p>
<p>按照React的开发模式，随着我们自下而上的重构业务，很自然的，下面的组件的“Model”部分会逐渐“上浮“与上层的组件的Model合并成为一个更大的Model。如此往复，我们自然会形成“整个应用只有一个大Model”的局面。我们需要在这一切发生之前想明白这个“大Model”内部要如何组织，会以何种形式存在，并以何种形式和各个组件交互。</p>
<p>类似，从View的角度看，我们最终会形成“整个应用就是一个大的React组件”。对于每一个业务动作，整个应用都会重新render。这个render的性能迟早我们需要关心。如何控制这个render的性能使之不会影响用户体验？</p>
</blockquote>
<h2 id="react引入的意义">react引入的意义</h2><h3 id="活力">活力</h3><p>引入后我觉得最重要的成就就是让一个系统拥有升级换代的活力。就像注入新鲜血液一样，系统能够跟上时代的变化。  </p>
<p>对于一个庞大的商业系统而言，系统底层的稳定性是一个很重要的点。不过如果能在在系统上面做一些侵入性的改造，让一个稳定的系统充满活力还是很有意义的。  </p>
<p>首先对于业务开发人员，很明显，他们在原有系统上面开发了这么久以后，对于新技术的引入是非常欢迎的，他们是非常乐意去学习新技术的。  </p>
<h3 id="提高开发效率">提高开发效率</h3><p>这个是写给老板们看的，花这么大力气去引入一个新技术对于公司的收益就是提高开发人员的效率。  </p>
<p>当然这个提高的效率的前提是对于开发人员有更高的要求的。</p>
<h3 id="提高系统的健壮性">提高系统的健壮性</h3><p>react的模式是可以在某种程度上面融入UT的。<br>以及一个很好的数据驱动模式维护性和扩展性是比现有系统强的。</p>
<h3 id="回放用户行为">回放用户行为</h3><p>数据驱动好处就是可以通过数据记录用户的页面状态，用数据就能恢复页面快照，需要分析用户行为，只需要收集到页面的数据变化流即可。</p>
<h2 id="react引入的挑战">react引入的挑战</h2><ol>
<li>数据驱动最合适的是从根部重构。但是目前我们只能从叶子模块一点点往根部重构。其实是一个反向过程。  </li>
<li>数据驱动模式对于开发人员要求比较高，能不能设计一种模式降低要求，避免出现不同水平的开发者开发出层次不齐的业务模块。</li>
<li>引入新的模式一个缺点就是以前模式成为了技术债务。因为一个系统存在多种模式，意味着新人学习成本会增加很多。多种模式的共存，如果维护不好，也会出现一种很混乱的现象。</li>
</ol>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/17/前端数据驱动的陷阱/" itemprop="url">
                前端数据驱动的陷阱
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-02-17T13:44:37+08:00" content="2016-02-17">
            2016-02-17
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/trap.jpg" alt="前端数据驱动的陷阱"></p>
<p>年前一篇文章<a href="http://tangguangyao.github.io/2016/01/30/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BB%B7%E5%80%BC/">《前端数据驱动的价值》</a>聊了一下数据驱动的一些看法。  </p>
<p>其中数据驱动的核心在于整个系统中对于数据的架构，设计，维护。对于数据的处理直接决定了系统的稳定性，可维护性，可扩展性。但是这里的数据维护也是相当复杂和难搞的一块。  </p>
<h2 id="精选评论">精选评论</h2><p>引用<code>nightire</code>在<code>segmentfault</code>对于《前端数据驱动的价值》的评论：<br>我觉得非常好所以完整复制过来</p>
<blockquote>
<p>数据驱动肯定不是从 flux/redux + react 才开始的<br>上者特别强调单向数据流，所以才给人造成“由它开始”的错觉</p>
<p>单向数据流有一个前置依赖，那就是 Single Data Source，也就是你的“提线木偶”所描述的那样</p>
<p>然而在你的文章里却把它写成了 Data Driven 的前置依赖</p>
<p>问题来了：只有单向数据流才算数据驱动吗？</p>
<p>肯定不是的，其实老牌的 Angular／Ember／……等等都是一样的，无非就是对待 Data 的方式各有不同罢了；刨除这些细微差别，它们都是从 “DOM 驱动” 转向 “数据驱动” 的代表作品</p>
<p>只是它们并没有把这个的概念提炼的深入人心，如此说来，React 一家是功不可没的，不可变数据 ＋ 单向数据流让数据驱动真正成为了“理念”，而不只是“概念”</p>
<p>然而，单向数据流也不是十全十美的，对于 UI 编程来说，有些地方的确是双向绑定来得更“漂亮”一些，比如：表单</p>
<p>所以 React 也适时的加入了双向绑定；不过这并不妨碍数据驱动这一理念得以贯彻</p>
<p>Single Data Source 也不是万能灵药，如果 A B C 三个模块都是各自独立开发的，之后因为需求而要合并在一起，怎么办？在它们之上再来一个 SDS？那这样还算不算是 SDS 呢？（或者反过来，不是 SDS 的话难道就不行吗？）</p>
<p>这个问题其实也还在发展中，这会儿我也给不出答案，只是客观描述一番罢了。</p>
</blockquote>
<h2 id="数据驱动的陷阱">数据驱动的陷阱</h2><p>对于一个真正完美的数据驱动，就如同《前端数据驱动的价值》中的例子，所有业务全部由一个<code>store</code>驱动，维护好<code>store</code>就是维护好了整个系统。  </p>
<p>但是对于这个一笔带过的维护<code>store</code>其实技术含量非常高。  </p>
<p>下面分业务场景和情况描述</p>
<h3 id="新项目">新项目</h3><p>这种情况是比较幸运的，开始的模型中设计好业务数据结构，设计好未来可扩展点。</p>
<p>当然，即使是新产品，也会遇到麻烦点，因为每一个参与开发的人，必须要全局的理解整个数据结构。  </p>
<p>看看数据难搞的地方，举个例子：  </p>
<p>模式A:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">	userInfo: &#123;</span><br><span class="line">		name: <span class="string">'test'</span>,</span><br><span class="line">		age: <span class="string">'20'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	planNum: <span class="number">2</span>,</span><br><span class="line">	plans: &#123;</span><br><span class="line">		<span class="string">'plan1'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan1'</span>,</span><br><span class="line">			price: <span class="number">2.00</span>,</span><br><span class="line">			unitNum: <span class="number">1</span>,</span><br><span class="line">			unit: &#123;</span><br><span class="line">				<span class="string">'unit1'</span>: &#123;</span><br><span class="line">					name: <span class="string">'unit1'</span>,</span><br><span class="line">					price: <span class="number">1.22</span>,</span><br><span class="line">					keywordNum: <span class="number">2</span>,</span><br><span class="line">					keyword: &#123;</span><br><span class="line">						<span class="string">'keyword1'</span>: &#123;</span><br><span class="line">							name: <span class="string">'word1'</span>,</span><br><span class="line">							price: <span class="number">22.00</span></span><br><span class="line">						&#125;,</span><br><span class="line">						<span class="string">'keyword2'</span>: &#123;</span><br><span class="line">							name: <span class="string">'word2'</span>,</span><br><span class="line">							price: <span class="number">21.00</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'plan2'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan2'</span>,</span><br><span class="line">			price: <span class="number">3.00</span>,</span><br><span class="line">			unitNum: <span class="number">0</span>,</span><br><span class="line">			unit: &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一种最简单的数据结构，清晰的展现了<code>plan</code>、<code>unit</code>、<code>keyword</code>直接的关系，简单直白。  </p>
<p>但是如果当层级关系越来越深，这个里面增删改查信息就是一个麻烦点，可以说上面结构的可扩展性不强。  </p>
<p>那么换下面一种结构是否更加合适：  </p>
<p>模式B:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">	userInfo: &#123;</span><br><span class="line">		name: <span class="string">'test'</span>,</span><br><span class="line">		age: <span class="string">'20'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	planNum: <span class="number">2</span>,</span><br><span class="line">	plans: &#123;</span><br><span class="line">		<span class="string">'plan1'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan1'</span>,</span><br><span class="line">			price: <span class="number">2.00</span>,</span><br><span class="line">			unitNum: <span class="number">1</span>,</span><br><span class="line">			unit: [unit1]</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'plan2'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan2'</span>,</span><br><span class="line">			price: <span class="number">3.00</span>,</span><br><span class="line">			unitNum: <span class="number">0</span>,</span><br><span class="line">			unit: []</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	units: &#123;</span><br><span class="line">		<span class="string">'unit1'</span>: &#123;</span><br><span class="line">			plan: <span class="string">'plan1'</span>,</span><br><span class="line">			name: <span class="string">'unit1'</span>,</span><br><span class="line">			price: <span class="number">1.22</span>,</span><br><span class="line">			keywordNum: <span class="number">2</span>,</span><br><span class="line">			keyword: [keyword1]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	keywords: &#123;</span><br><span class="line">		<span class="string">'keyword1'</span>: &#123;</span><br><span class="line">			plan: <span class="string">'plan1'</span>,</span><br><span class="line">			unit: <span class="string">'unit1'</span>,</span><br><span class="line">			name: <span class="string">'word1'</span>,</span><br><span class="line">			price: <span class="number">22.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'keyword1'</span>: &#123;</span><br><span class="line">			plan: <span class="string">'plan1'</span>,</span><br><span class="line">			unit: <span class="string">'unit1'</span>,</span><br><span class="line">			name: <span class="string">'word2'</span>,</span><br><span class="line">			price: <span class="number">21.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人感觉这种模式更加适合，便于查找和更新，那么问题来了，先抛开哪种数据结构更合适问题，假如开发初期<code>模式A</code>是ok的，随着业务的复杂，发现<code>模式A</code>越来越难维护，经过重新设计，发现转换到<code>模式B</code>更加合适，能明显提高开发和维护效率，那么怎么办？  </p>
<p>个人还没有实践过，但是经验上看感觉是会导致大面积重构。即使重构完成，假如后期发现更好的数据模式呢？  </p>
<p>所以可以看出初期的数据结构决定了未来架构，看上去像不像后端开发，数据库的设计很重要。  </p>
<p>既然越来越像后端设计模式，那么是否会模仿当时的前后端分离策略，底层数据结构和业务展现通过api实现呢？个人感觉这样有点问题过于复杂化。那么是否可以加一个中间数据转换层去处理数据呢？这样在底层数据结构变换时，也能避免直接影响业务模块，中间层做一个适当的解耦，展示内容和数据结构没有什么关联，关联的仅仅是数据信息。</p>
<p><strong>结论一：初期的数据结构设计会是未来的不定时炸弹，迟早会面对，需要有相应策略</strong></p>
<h3 id="模块合并">模块合并</h3><p>再来考虑评论中的一个问题：  </p>
<blockquote>
<p>Single Data Source 也不是万能灵药，如果 A B C 三个模块都是各自独立开发的，之后因为需求而要合并在一起，怎么办？在它们之上再来一个 SDS？那这样还算不算是 SDS 呢？（或者反过来，不是 SDS 的话难道就不行吗？）</p>
</blockquote>
<p>复杂的系统中确实会遇到这种问题，直接举例：  </p>
<p>模块C，主要负责修改level:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">	moduleA: &#123;</span><br><span class="line">		<span class="string">'plan1'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan1'</span>,</span><br><span class="line">			price: <span class="number">22.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">		level: <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块D，主要负责修改auth:  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">	moduleB: &#123;</span><br><span class="line">		<span class="string">'plan1'</span>: &#123;</span><br><span class="line">			name: <span class="string">'plan1'</span>,</span><br><span class="line">			price: <span class="number">22.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">		auth: <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的逻辑是假如两个独立开发好的模块需要合并到一起，他们都有各自模块的内部数据结构，假如模块C除了修改level，还修改了plan1的name会怎么样？为了保证数据统一，需要去找到模块D中的plan1信息，并且修改。假如他们都合并到上面一个例子模块A中怎么办，是否还需要继续同步修改。如果漏掉一个同步，展示上，以及后面的处理都会引发各种bug。  </p>
<p>当然，如果不用数据驱动，可能这种模块合并也是需要从展示层级各处同步修改信息的，也会特别麻烦。只是相比较而言，数据驱动的这种合并同步并没有给我们带来很清晰简单的处理方式。  </p>
<p><strong>结论二：数据驱动下，数据的重复和同步是一个坑，要尽量避免</strong></p>
<h3 id="不适合的场景">不适合的场景</h3><blockquote>
<p>然而，单向数据流也不是十全十美的，对于 UI 编程来说，有些地方的确是双向绑定来得更“漂亮”一些，比如：表单  </p>
</blockquote>
<p>评论里面提到的这部分应该是单向数据流的一个痛点，如果模块里面严格执行单向数据流，对于这种表单验证来说，是非常痛苦的。  </p>
<p>例如：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = &#123;</span><br><span class="line">	<span class="keyword">value</span>: <span class="number">2.00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应一个输入框，输入框只能限制输入1-100的2位小数。整个验证过程单向数据驱动就会特别麻烦。  </p>
<p>一个简单的例子，在使用react实现表单验证就比较麻烦。</p>
<p><strong>结论三:对于某些具体的模块，单向数据流不是万灵药，整体架构单向数据驱动，具体模块可以根据场景选择最合适的</strong></p>
<h2 id="总结">总结</h2><p>个人感觉数据驱动对于开发人员的要求其实有一些增加，开发是需要更多的全局观，对于业务需要更加的了解。这个其实算是缺点，因为从工程化的角度，这种模式提高了开发成本，提高了开发人员的学习成本。  </p>
<p>那么优点呢，应该是系统的稳定性，可维护性，健壮性会更好。</p>
<p>总之没有银弹，每种模式都有适合的场景。以上就是对于数据驱动的一点点看法。仅供参考。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/30/前端数据驱动的价值/" itemprop="url">
                前端数据驱动的价值
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-30T22:29:06+08:00" content="2016-01-30">
            2016-01-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>数据驱动应该是从<code>flux/redux</code> + <code>react</code>这种模式开始流行的。 </p>
<p>他的背后不仅仅是数据驱动这么简单，在复杂的系统中，我觉得它解决了一个很关键的问题就是模块间的交互/通信。有很多文章拿他和mvc/mvvm去比较，我个人觉得没有特别的可比性，因为解决的问题不同。 </p>
<h2 id="以往处理模式">以往处理模式</h2><p>一个稍微复杂点的例子：  </p>
<p><img src="/img/res/5/module.png" alt="模块"></p>
<p>假如有这么一个页面，我们按照以往模式开发，首先模块化开发，拆分成A，B，C 三个模块，然后每个模块有自己的子模块。  </p>
<p>如果需求简单还比较好解决，每个模块中自己解决自己的逻辑，解耦的非常清晰。父子之间的关系也非常明确。 </p>
<ol>
<li>例如销毁<code>C模块</code>，会自动销毁它的子模块<code>C1</code>和<code>C101</code>。  </li>
<li>模块间的关系也很清晰，<code>B1</code>不会和<code>B2</code>有直接关系，他们之间需要通过<code>B模块</code>去传递。同理，<code>B模块</code>和<code>A模块</code>也没有直接关系，他们都需要通过外层<code>页面</code>去处理关系。</li>
</ol>
<p>但是假如有这么一个需求，<code>A2</code>的显示和<code>B2</code>（用户交互）以及<code>C101</code>（用户交互）相关怎么办。</p>
<p>按照这种模式，它的解决方案是：  </p>
<p><code>B2</code>如果发生改变，通知<code>B模块</code>，<code>B模块</code>在通知<code>页面</code>，<code>页面</code>调用<code>A模块</code>和<code>C模块</code>，<code>C模块</code>调用<code>C1</code>，<code>C1</code>调用<code>C101</code>获取<code>C101</code>的数据处理，<code>页面</code>调用<code>A模块</code>，<code>A模块</code>再调用<code>A2</code>，再结合一下从<code>C101</code>获取的数据，改变它的展示。 </p>
<p>是不是看着很绕，从图上看是这么个关系：</p>
<p><img src="/img/res/5/model02.png" alt="模块"></p>
<p>图中仅仅显示了其中一个复杂交互，假如我们再多两个模块间关联的逻辑：  </p>
<ol>
<li><code>B1</code>和<code>B2</code>模块影响<code>A2</code>模块(图中黄线)</li>
<li><code>C1</code>影响<code>B1</code>模块(图中白线)</li>
</ol>
<p>如下图：   </p>
<p><img src="/img/res/5/model03.png" alt="模块"></p>
<p>3个复杂一点的交互，整个模块间的通信已经变成蜘蛛网了，重要的是，每一条关系线都需要开发者维护的，不仅影响开发效率，而且不好维护，容易引发bug，假如后期加新需求或者调整需求，开发成本都是比较高的。</p>
<p>可见，对于复杂的交互，或者模块间关系复杂时，这种依赖父子关系的通信，是一个很大的障碍。  </p>
<p>但是我们怎么办，拒绝模块化开发吗？那样页面设计起来耦合度更大，更加不可维护。</p>
<p>首先一点，模块化开发是一个不可逆的趋势，然而在这种趋势下，解决模块化通信是一个非常重要的点。  </p>
<h2 id="模块间通信其他方案">模块间通信其他方案</h2><p>在那个时候，我考虑最多的就是如何去解决模块之间的通信，如何让模块之间交互更加轻松，模块之间更加独立。</p>
<h3 id="方案一：">方案一：</h3><p>当时考虑的一个方案是使用一个全局的event（全局的on和fire）。这样模块之间就不用依赖父子关系了。模块和模块间是可以之间交互的。</p>
<p>但是这样会有一些弊端：</p>
<ol>
<li>事件名称如何定义，保证不重名  </li>
<li>事件是否会重复的on</li>
<li>模块和模块之间会因为事件产生一些耦合</li>
<li>当交互特别复杂时，也会比较麻烦，还是上面的例子，<code>B2</code>通知<code>C2</code>改变后，<code>C2</code>还需要通知<code>C101</code>获取一次数据，来确认改变</li>
</ol>
<p>整体来看：  </p>
<p>优势： 摆脱了模块间父子层级关系，可以简单的跨模块通信  </p>
<p>劣势： 依然需要维护复杂的模块间关系，只是可以绕过父子依赖 </p>
<h3 id="方案二:">方案二:</h3><p>全局共享一个model + component模式。这种其实已经非常趋向与数据驱动了。每个模块都是共享全局的model，然后每个component都可以被全局获取到到，里面的功能属性可以直接被使用。  </p>
<p>其实这种模式已经比较理想，页面上面的任何component都可以被直接调用到并且使用。</p>
<p>个人觉得缺点就是：<br>多了一个全局可调用component的功能。如果砍掉他可以实现完成数据驱动，如果模块调用时，使用多了直接获取component的功能，还是需要在模块间维护好和其他模块间的交互逻辑。 </p>
<h2 id="数据驱动">数据驱动</h2><p>先看一个图，我感觉可以很好的体现数据驱动  </p>
<p><img src="/img/res/5/model01.jpg" alt="提线木偶"></p>
<p>提线木偶：他的特点就是每个动作都是，头，手臂，脚，金箍棒都是由操作的人手决定的，头和手臂直接没有任何关系。  </p>
<p>数据驱动也可以这么理解，页面上面所以的展示都是由数据决定的，和页面其他地方没有任何关系。</p>
<p>再来看看上面那个例子如果加上数据驱动的设计思想。   </p>
<p><img src="/img/res/5/model.png" alt="数据驱动"></p>
<p>页面之间每个模块，不用关心父子模块之间的关系，每个独立的模块都是由一个全局的model决定。</p>
<p>回到上面那个麻烦的场景。当<code>B2</code>改变时，它会修改model中对应的数据（效验C101数据，结合B2的改变，修改A2的数据），然后A2的业务模块跟进A2的数据改变。  </p>
<p>这种设计的核心是每一个模块的改变，全部都交给model处理。  </p>
<p>然后model里面会和个个模块一一对应，每个模块无需关注其他模块的变化，只需要关注model里面对应自己数据的变化即可。所以模块间关系链条会显得非常简单。  </p>
<p>重点在于，当交互逻辑不断增加时，这个关系链条依然不会增加，因为模块只和model里面对于的数据相关联。</p>
<p>当然，这种模式也无法去省略复杂的业务逻辑，只是业务逻辑全部都会聚集在model中。可以理解为页面上所有的操作都是对数据的操作。然后每个模块只需要监听关注的数据改变即可，这个监听关系就是图中唯一的一条关系线。 </p>
<p>换一个理解，我们将直接的模块和模块直接的耦合关系全部转移到了数据中去体现。而数据的维护是远远比模块更好维护的。  </p>
<h2 id="Model如何对应View">Model如何对应View</h2><p>还是上面页面为例子：  </p>
<p>model  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var page = &#123;</span><br><span class="line">	a: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			a1: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			a2: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	b: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			b1: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			b2: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	c: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			c1: &#123;</span><br><span class="line">				isShow: true,</span><br><span class="line">				children: [&#123;</span><br><span class="line">					c101: &#123;</span><br><span class="line">						isShow: true</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isShow 表示展示的意思。这个状态对应文章第一个图片。  </p>
<p><img src="/img/res/5/module.png" alt="模块"></p>
<p>当数据改变时，例如model发生变化如下：  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var page = &#123;</span><br><span class="line">	a: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			a1: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			a2: &#123;</span><br><span class="line">				isShow: false</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	b: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			b1: &#123;</span><br><span class="line">				isShow: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			b2: &#123;</span><br><span class="line">				isShow: false</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	c: &#123;</span><br><span class="line">		isShow: true,</span><br><span class="line">		children: [&#123;</span><br><span class="line">			c1: &#123;</span><br><span class="line">				isShow: false,</span><br><span class="line">				children: [&#123;</span><br><span class="line">					c101: &#123;</span><br><span class="line">						isShow: true</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应下面这样： </p>
<p><img src="/img/res/5/model04.png" alt="数据驱动"></p>
<p>换一个理解就是每一种数据状态对应一种页面的展示状态。页面想展示成什么样子，需要数据处理成什么样子。数据是这个页面的核心。  </p>
<h2 id="数据驱动开发关注点">数据驱动开发关注点</h2><p>第一点数据结构的处理，因为数据决定了整个页面的展示，数据结构开始的设计非常关键，数据结构的可扩展性决定了页面的可扩展性，如果开始数据模式不好，后期维护也会非常难受。  </p>
<p>第二点是处理好模块和数据中对应的关系。  </p>
<p>可以看到数据驱动的难点和关键点就是数据结构的设计。而这个也是很考验开发者能力的。数据结构的好坏直接决定了后期业务开发的质量。</p>
<h2 id="数据驱动和mvc/mvvm的关系">数据驱动和mvc/mvvm的关系</h2><p>文章开头说了，从我的角度理解数据驱动这种模式和mvc并没有什么竞争关系，在具体的实践中，每一个模块可以是一个mvc或者mvvm，模块的内部处理交给模块自己，可以是mvc,或者单例也可以。数据驱动主要是处理模块之间的一种逻辑。  </p>
<p>那么为什么数据驱动和react这种结合的更加好了？因为react更进一步是讲模块内部也实现一个数据驱动，模块内部的数据改变了，模块的状态会跟着改变。  </p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/20/当扔给你一个bug时，你会怎么办/" itemprop="url">
                当扔给你一个bug时，你会怎么办
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-20T20:58:04+08:00" content="2016-01-20">
            2016-01-20
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/bug.jpeg" alt="当扔给你一个bug时，你会怎么办"></p>
<p>当你的老大给你分配一个bug时，你会怎么想？  </p>
<p>如果简单，之前遇到过还好，如果完全没有头绪呢，一看就很麻烦呢？  </p>
<p>估计第一反应就是what the F** ……</p>
<p>呵呵，其实我最近就干了这些事，分配了一些感觉比较麻烦bug给组里面的同学。  </p>
<h2 id="从技能角度">从技能角度</h2><p>因为从我的经验上看，解决bug是一个迅速提高技术的捷径。你想想如果项目中没有遇到任何bug，或者比较麻烦的点，你会主动debug到项目依赖的框架中吗？即使你有目的的去了解框架，你会像定位bug那样有目的性吗？  </p>
<p>定位bug其实就是要求你在一定时间内，去有目的性的（开始没有目的也要逐步梳理出眉目）研究框架中某一些技术点。  </p>
<p>假设耗费了很大的力气还没有找到问题，你在求助其他人时，你也会很认真的看他怎么定位bug，看看自己定位的思路和他的差距在哪里。这个差距就是你快速学习的内容。  </p>
<h2 id="从项目角度">从项目角度</h2><p>在项目上，有一个比较重要的衡量标准：</p>
<blockquote>
<p>快速定位问题和解决问题的能力  </p>
</blockquote>
<p>我觉得这个在技术行业，非常重要。直接决定了你是否能独立承担项目。能力越强，越能承担负责的项目。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼">  </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/14/AMD的一道面试题/" itemprop="url">
                AMD的一道面试题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-14T10:59:49+08:00" content="2016-01-14">
            2016-01-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/amd.jpg" alt="AMD的一道面试题"></p>
<p>模块化现在应该已经成为了稍微复杂一点前端开发的标配了。在es6中，都已经支持了的模块化。  </p>
<p>之前的面试中，一直感觉模块化AMD,CMD没有什么可以问的，不过昨天面试突然想到一个题目：<br>对于一个AMD的模式下</p>
<p>文件<code>d.js</code>如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">	<span class="comment">// ... 很多代码</span></span><br><span class="line">	<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>a.js</code>,<code>b.js</code>,<code>c.js</code> 文件分别是什么时候加载的，如何加载的？</p>
<p>题目不难</p>
<p>答案是<code>a.js</code> 和 <code>c.js</code> 是在加载完<code>d.js</code>后就加载。<br><code>b.js</code>是在执行到这一行时异步加载的。</p>
<p>具体分析：</p>
<p>我没有看过<code>require.js</code>的源码，我们使用的是<code>esl.js</code>（也是一个AMD的模块加载器）,但是他们的实现原理应该差不多。</p>
<p>我从<code>esl.js</code>的角度解读一下：</p>
<h3 id="同步加载，异步加载">同步加载，异步加载</h3><p>首先大家需要知道AMD里面一个同步加载和异步加载的概念。</p>
<p>从概念上面理解，同步就是当我执行到<code>require(&#39;a&#39;);</code>时，我需要同步的执行<code>a.js</code>里面的内容，也就是需要在执行到这句话时<code>a.js</code>必须已经加载好了，这样才能到达同步。</p>
<p>而对于 <code>require([&#39;b&#39;], function (b) {});</code>,我执行到这一步时，是异步的发出请求，然后异步等待<code>b.js</code>的返回+执行。</p>
<h3 id="同步加载的实现原理">同步加载的实现原理</h3><p>我们从概念上面理解的同步加载的原理，现在看看<code>esl.js</code>的实践。<br>这里面需要处理两个核心步骤  </p>
<ol>
<li>执行到<code>require(&#39;a&#39;);</code>时，<code>a.js</code>必须已经加载好了；</li>
<li><code>a.js</code>文件里面的所有<code>require(&#39;*&#39;)</code>，也都必须加载好了，保证在执行<code>a.js</code>时，所有<code>a.js</code>依赖的同步文件都能同步执行；</li>
</ol>
<p>对于第一步的实现，大概原理是这样的，在加载好了<code>d.js</code>后，会正则匹配一次文件里面的同步依赖<code>require(&#39;*&#39;);</code>，例如匹配出了 <code>a.js</code>和<code>c.js</code>，然后继续加载<code>a.js</code>和<code>c.js</code>。  </p>
<p>对于第二部，其实就是一个递归处理，直到没有下一步的依赖为止。</p>
<h3 id="同步加载另外一种处理方法">同步加载另外一种处理方法</h3><p>上面有一部正则逻辑，可见如果使用这种方式，在执行代码前，js需要全部正则一次所有模块化代码的。这样性能是不是有一个无谓的耗损。  </p>
<p>那么我们一般怎么处理了？  </p>
<p>大家一般都了解过打包编译，例如在使用<code>Requirejs</code>时，线上环境的代码会经过<code>r.js</code>处理一次。  </p>
<p>那么<code>d.js</code>文件应该会处理如下 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">	<span class="string">'path/b'</span>,</span><br><span class="line">	[<span class="string">'require'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>define方法会增加第一个和第二个参数  </p>
<p>第一个参数是按照路径生成一个具名id<br>第二个参数是此文件所依赖的同步文件</p>
<p>这时当模块在解析这个<code>b,js</code>文件时，发现如果存在第二个参数，就会直接解析所需依赖部分，而省去了正则这一步。  </p>
<p>我们正则这一步转换到了打包编译中去分析，这样就省掉了浏览器加载时去正则所有AMD文件这一步。  </p>
<p>那么为什么我们不在开发环境中直接使用<code>[&#39;require&#39;, &#39;a&#39;, &#39;b&#39;]</code>方式，我理解目的是为了提高开发便捷性，我们不需要再增加一个<code>require(&#39;*&#39;)</code>都在中括号内配置一次，同样删除时也不用去删掉配置。  </p>
<p>因为这一步完全可以在编译时处理。  </p>
<h3 id="打包编译的延生">打包编译的延生</h3><p>不知道大家有没有看过编译后的代码和开发环境代码的区别，对于这个<code>b.js</code>文件，编译后应该是： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">	<span class="string">'path/a'</span>,</span><br><span class="line">	[<span class="string">'require'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(</span><br><span class="line">	<span class="string">'path/c'</span>,</span><br><span class="line">	[<span class="string">'require'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(</span><br><span class="line">	<span class="string">'path/b'</span>,</span><br><span class="line">	[<span class="string">'require'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;&#125;);</span><br><span class="line">		<span class="comment">// ... 很多代码</span></span><br><span class="line">		<span class="built_in">require</span>(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面可见，<code>a.js</code>和<code>c.js</code>这两个文件被合并到了<code>d.js</code>中，所有文件都加上了具名id。而且这个id的生成规则是更具路径生成的。  </p>
<p>而我们异步加载的<code>b.js</code>文件就没有被打包进来。这是因为我们期望<code>b.js</code>是懒加载的，当使用时在加载，这样也能达到按需加载的目的。</p>
<h3 id="微信公众号">微信公众号</h3><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/05/前端发展论战/" itemprop="url">
                前端发展论战
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-05T13:54:45+08:00" content="2016-01-05">
            2016-01-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/topics.jpg" alt="前端发展论战"></p>
<h2 id="最近很热的讨论">最近很热的讨论</h2><blockquote>
<p>关于『真阿当』对目前流行前端技术的批判 <a href="https://www.zhihu.com/question/38924821" target="_blank" rel="external">https://www.zhihu.com/question/38924821</a></p>
<p>Winter - 我眼中的前端框架jQuery，Angular，React，Vue——以及我看前端架构<a href="http://weibo.com/p/1001603924826640228007" target="_blank" rel="external">http://weibo.com/p/1001603924826640228007</a></p>
<p>关于前端工具变化过快的讨论 <a href="https://www.zhihu.com/question/34449620" target="_blank" rel="external">https://www.zhihu.com/question/34449620</a></p>
<p>我感觉到的前端变化 <a href="http://bbear.me/wo-suo-gan-jue-dao-de-qian-duan-bian-hua/" target="_blank" rel="external">http://bbear.me/wo-suo-gan-jue-dao-de-qian-duan-bian-hua/</a></p>
</blockquote>
<p>上面几篇文章对于前端的发展讨论较多。</p>
<h2 id="前端变化过快的看法">前端变化过快的看法</h2><p>首先，不得不承认前端变化确实太快，对于我而言，react还在了解，没有真正的落地业务时，vue又开始兴起，马上angular2可能又会开始火。。。 </p>
<p>变化如此之快，我们该如何面对？  </p>
<p>第一，我觉得首先需要避免盲目追新，如果对于新框架只是简单的写写demo，意义是不大的。</p>
<p>为什么了？如果没有复杂的项目支撑，你会踩不到框架的坑，你不会体会到框架哪里设计的巧妙，哪里设计的不足。你也很少有机会为了研究巧妙的实现去看部分的源码。而这个过程其实是使用框架的精髓。  </p>
<p>第二，更加深入的加强基础技能，框架会不断更新，更新也会越来越快，只有不断强化一些基础技能，才能够很快的去了解新框架，达到新框架即学即用的能力。</p>
<p>如何提高基础技能呢？就研究下你现在用的框架，或者找一个你觉得很好的框架，深入研究下他的设计思路，源码等等，反复研究，反复体会，花上3个月深入研究一个。当你研究透了，你在看其他框架，相信我，你看的角度会变。</p>
<h2 id="我们对于新技术如何使用">我们对于新技术如何使用</h2><p>现在团队使用的还是百度自己一套mvc框架，但是当我们在尝试新技术时，我们其实可以很快的即学即用的，es6，react，vue这些的使用并没有什么障碍。</p>
<p>即使我们目前工作都是集中在pc端，我们团队的成员也是可以迅速上手移动端的开发的，我理解很大一部分因素都是基础能力比较扎实。</p>
<p>所以我感觉，请放心，如果没有用到最新的技术，不要害怕。</p>
<h2 id="前端的发展">前端的发展</h2><p>个人感觉未来的前端更加偏向解决方案的方式，一个合格的架构师能够根据业务，以及开发成员的状态，选择最合适的开发方式，合作方式。</p>
<p>未来的框架，工程化方案会越来越多，你需要做到的是，能够即插即用的能力。在面对一个新框架时，能够快速判断出框架是否适合于业务，是否能提高开发效率。</p>
<p>回到阿当的微博</p>
<blockquote>
<p>sass和less最近是不是被提起得少了?backbone呢?响应式设计呢?今天说得起劲的angular和rect，是不是半年后也逐渐消停了呢?一切不接地气的性价比不高的伪高端，都会消停的。我相信jquery还能坚挺5年，不相信rect和angular能热过两年。踩jquery的一直不会停，新时髦也不会停。话放在这儿，两年后咱看看。</p>
</blockquote>
<p>我理解，大家不要把注意力放到各种各样的框架上，打好基础，什么新框架都能hold住，岂不是最好。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/16/使用node子进程spawn-exec踩过的坑/" itemprop="url">
                使用node子进程spawn,exec踩过的坑
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-16T15:20:16+08:00" content="2015-12-16">
            2015-12-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/child_process.png" alt="使用node子进程spawn,exec踩过的坑"></p>
<p><em>如何在项目中实现热更新</em>中提到的一个坑child_process的exec使用问题，下面文章会详细介绍下，debug到node源码中的详细介绍，不容错过。</p>
<h2 id="child_process介绍">child_process介绍</h2><p>Nodejs是单线程单进程的，但是有了child_process模块，可以在程序中直接创建子进程，并使用主进程和子进程之间实现通信。  </p>
<p>对于child_process的使用，大家可以找找其他文章，介绍还是比较多的，本文主要讲一下踩过的坑。</p>
<h2 id="踩过的坑">踩过的坑</h2><p>在使用<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a>这个工具时（对于工具的介绍，参考前面的文章<em>如何在项目中实现热更新</em>），发现用子进程启动项目，经常性的挂掉。然后也不知道为什么，甚至怀疑子进程的效率比较低。  </p>
<p>最后为了进一步验证，在同样的环境下，一个直接启动服务，一个是使用<code>require(&#39;child_process&#39;).exec(&#39;...&#39;)</code> 方式启动。  </p>
<p>最后发现使用子进程打开还真的就是使用到一定程度就挂掉。虽然此时也没有什么解决方案，但是至少能把问题定位在子进程上了，而不是其他工具代码导致程序挂掉。  </p>
<h2 id="定位问题">定位问题</h2><p>定位了问题后，网上查找child_process相关资料，发现<a href="http://deadhorse.me/nodejs/2011/12/18/nodejs%E4%B8%ADchild_process%E6%A8%A1%E5%9D%97%E7%9A%84exec%E6%96%B9%E6%B3%95%E5%92%8Cspawn%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">exec与spawn方法的区别与陷阱</a> 这篇文章提到几点：  </p>
<ol>
<li>exec与spawn是有区别的</li>
<li>exec是对spawn的一个封装</li>
<li>最重要的exec比spawn多了一些默认的option </li>
</ol>
<p>基于以上几点有些头绪了，但是还是没有明确的解决方案。  </p>
<p>最后一个办法，直接断点到nodejs的child_process.js模块中尝试看看问题出在哪里。  </p>
<h2 id="exec和spawn的源码区分">exec和spawn的源码区分</h2><p>断点进去看后，豁然开朗，<code>exec</code>是对<code>execFile</code>的封装，<code>execFile</code>又是对<code>spawn</code>的封装。  </p>
<p>每一层封装都是加强一些易用性以及功能。  </p>
<p>直接看源码：  </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exports.exec = </span><br><span class="line">	<span class="function"><span class="keyword">function</span><span class="params">(command <span class="comment">/*, options, callback*/</span>)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">var</span> opts = normalizeExecArgs.apply(<span class="literal">null</span>, arguments);</span><br><span class="line">  		<span class="keyword">return</span> exports.execFile(opts.file,</span><br><span class="line">                          		opts.args,</span><br><span class="line">                          		opts.options,</span><br><span class="line">                          		opts.<span class="keyword">callback</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>exec</code>对于<code>execFile</code>的封装是进行参数处理  </p>
<p>处理的函数：</p>
<p><code>normalizeExecArgs</code>  </p>
<p>关键逻辑</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">    <span class="keyword">file</span> = process.env.comspec || <span class="string">'cmd.exe'</span>;</span><br><span class="line">    args = [<span class="string">'/s'</span>, <span class="string">'/c'</span>, <span class="string">'"'</span> + command + <span class="string">'"'</span>];</span><br><span class="line">    <span class="comment">// Make a shallow copy before patching so we don't clobber the user's</span></span><br><span class="line">    <span class="comment">// options object.</span></span><br><span class="line">    <span class="keyword">options</span> = util._extend(&#123;&#125;, <span class="keyword">options</span>);</span><br><span class="line">    <span class="keyword">options</span>.windowsVerbatimArguments = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">file</span> = <span class="string">'/bin/sh'</span>;</span><br><span class="line">    args = [<span class="string">'-c'</span>, command];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将简单的command命名做一个，win和linux的平台处理。  </p>
<p>此时<code>execFile</code>接受到的就是一个区分平台的<code>command</code>参数。  </p>
<p>然后重点来了，继续debug，<code>execFile</code>中：  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    encoding: <span class="string">'utf8'</span>,</span><br><span class="line">    timeout: <span class="number">0</span>,</span><br><span class="line">    maxBuffer: <span class="number">200</span> * <span class="number">1024</span>,</span><br><span class="line">    killSignal: <span class="string">'SIGTERM'</span>,</span><br><span class="line">    cwd: <span class="literal">null</span>,</span><br><span class="line">    env: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有这么一段，设置了默认的参数。然后后面又是一些参数处理，最后调用<code>spawn</code>方法启动子进程。   </p>
<p>上面的简单流程就是启动一个子进程。到这里都没有什么问题。  </p>
<p>继续看，重点又来了：  </p>
<p>用过子进程应该知道这个<code>child.stderr</code></p>
<p>下面的代码就解答了为什么子进程会挂掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">child.stderr.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    stderrLen += chunk.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stderrLen &gt; options.maxBuffer) &#123;</span><br><span class="line">      ex = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'stderr maxBuffer exceeded.'</span>);</span><br><span class="line">      kill();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!encoding)</span><br><span class="line">        _stderr.push(chunk);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _stderr += chunk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>逻辑就是，记录子进程的log大小，一旦超过<code>maxBuffer</code>就<code>kill</code>掉子进程。  </p>
<p>原来真相在这里。我们在使用<code>exec</code>时，不知道设置<code>maxBuffer</code>，默认的<code>maxBuffer</code>是200K,当我们子进程日志达到200K时，自动<code>kill()</code>掉了。</p>
<h2 id="exec和spawn的使用区分">exec和spawn的使用区分</h2><p> 不过exec确实比spawn在使用上面要好很多</p>
<p> 例如我们执行一个命令</p>
<p> 使用exec</p>
<p> <code>require(&#39;child_process&#39;).exec(&#39;edp webserver start&#39;);</code></p>
<p> 使用spawn</p>
<p> linux下这么搞</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn(</span><br><span class="line">    <span class="string">'/bin/sh'</span>, </span><br><span class="line">    [<span class="string">'-c'</span>,<span class="string">'edp webserver start'</span>],</span><br><span class="line">    &#123;</span><br><span class="line">        cwd: <span class="literal">null</span>,</span><br><span class="line">        env: <span class="literal">null</span>,</span><br><span class="line">        windowsVerbatimArguments: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> win下</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn(</span><br><span class="line">    <span class="string">'cmd.exe'</span>,</span><br><span class="line">    [<span class="string">'/s'</span>, <span class="string">'/c'</span>, <span class="string">'edp webserver start'</span>],</span><br><span class="line">    &#123;</span><br><span class="line">        cwd: <span class="literal">null</span>,</span><br><span class="line">        env: <span class="literal">null</span>,</span><br><span class="line">        windowsVerbatimArguments: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可见spawn还是比较麻烦的。</p>
<h2 id="解决方案">解决方案</h2><p>知道上面原因了，解决方案就有几个了:  </p>
<ol>
<li>子进程的系统，不再输出日志</li>
<li>maxBuffer这个传一个足够大的参数</li>
<li>直接使用spawn，放弃使用exec</li>
</ol>
<p>我觉得最优的方案是直接使用<code>spawn</code>，解除<code>maxBuffer</code>的限制。但是实际处理中，发现直接考出<code>normalizeExecArgs</code>这个方法去处理平台问题，在win下还是有些不好用，mac下没有问题。所以暂时将<code>maxBuffer</code>设置了一个极大值，保证大家的正常使用。然后后续在优化成<code>spawn</code>方法。  </p>
<h2 id="吐槽">吐槽</h2><p>其实没有怎么理解，execFile对于spawn封装加maxBuffer的这个逻辑，而且感觉就算加了，是否也可以给一个方式，去掉maxBuffer的限制。  </p>
<p>难道是子进程的log量会影响性能？</p>
<h2 id="感想">感想</h2><p>其实在解决这个问题时，发现这个差异/坑还比较意外，因为自身对于node其实还不是很熟，这个子进程的使用其实也是在ehu中第一次遇到。  </p>
<p>感受比较多的就是有时候正对问题去学习/研究，其实效率特别高。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/15/如何在项目中实现热更新（下）/" itemprop="url">
                如何在项目中实现热更新（下）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-15T14:20:59+08:00" content="2015-12-15">
            2015-12-15
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="/img/res/update03.jpg" alt="如何在项目中修改代码后实现热更新"></p>
<p>本篇文章是最后一篇，主要讲一下在浏览器端的一些实现。和浏览器热更新的细节。</p>
<p>工具源码<a href="https://github.com/homkai/ehu" target="_blank" rel="external">EHU(esl-hot-update)</a></p>
<h2 id="浏览器端依赖">浏览器端依赖</h2><p><code>socket.io</code>——浏览器端仅仅依赖socket这个去和服务端通信  </p>
<p>通信逻辑</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line">socket.on(<span class="string">'hello'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    log(getLogMsgPrefix(), <span class="string">'HotUpdate已启动！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 检测到文件改动</span></span><br><span class="line">socket.on(<span class="string">'hotUpdate'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(file)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// log(getLogMsgPrefix(), '检测到文件改动', file);</span></span><br><span class="line">    <span class="comment">// ....处理文件修改后对应热更新逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="对css/less更新的处理">对css/less更新的处理</h2><p>这个原理比较简单，页面监听到样式的修改，重新加载一次样式即可，简单的覆盖。  </p>
<p>但是存在一个潜在问题，因为样式是简单的覆盖，所以，如果修改是删除了样式，是无法生效的。</p>
<p>举例：<br>修改前：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#FFFFFF</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#E8E8E8</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#FFFFFF</span></span></span>;</span><br></pre></td></tr></table></figure>
<p>删除的<code>border</code>和<code>margin-top</code>其实是没有生效的  </p>
<p>这个也是后期需要解决的一个问题。</p>
<h2 id="对模板更新的处理">对模板更新的处理</h2><p>目前项目中使用的是tpl的模板引擎。  </p>
<p>现在就遇到一个问题，在热更新时，模板引擎其实是重复加载模板的，那么就涉及到重复加载是否后面的会覆盖前面问题。  </p>
<p>查看加载模板的源码后，发现根据配置有三个选择，<code>覆盖</code>，<code>忽略</code>和<code>报错</code>， 我们业务中使用的配置是遇到重复后会报错处理，所以我们需要在不修改业务默认属性的情况下，添加一些逻辑。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [esl-hot-update] 重新加载需要覆盖</span></span><br><span class="line"><span class="built_in">window</span>.EHU_HOT_UPDATE_OPTIONS</span><br><span class="line">&amp;&amp; <span class="built_in">window</span>.EHU_HOT_UPDATE_OPTIONS.etpl.isOverride</span><br><span class="line">&amp;&amp; (namingConflict = <span class="string">'override'</span>);</span><br><span class="line"><span class="keyword">switch</span> (namingConflict) &#123;</span><br><span class="line">    <span class="comment">/* jshint ignore:start */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'override'</span>:</span><br><span class="line">        engine.targets[name] = target;</span><br><span class="line">        context.targets.push(name);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ignore'</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* jshint ignore:end */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Target exists: '</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>window.EHU_HOT_UPDATE_OPTIONS.etpl.isOverride</code>这个是修改后自己实现的控制配置修改的逻辑。  </p>
<p>然后这个文件加入到服务端的路由中，请求时替换。</p>
<h2 id="对js更新的处理">对js更新的处理</h2><p>这里逻辑比较复杂，因为需要修改底层的AMD模块加载的逻辑。  </p>
<p>js没有模板那么简单，不是直接覆盖，因为在AMD模式中，每一个文件，都是被上一个文件调用执行的结果。  </p>
<p>所以我们处理的逻辑是不仅需要重新加载修改的文件，并且递归所有直接或者间接调用他的文件，全部重新加载。  </p>
<p>所以从上面的特点可以看出，这个工具目前阶段主要适用于业务模块的开发，因为业务的依赖不会特别深，对于dep中的核心文件修改，就不是很合适，一旦文件比较底层，热跟新是重新加载的模块也会非常多。</p>
<p>另外也有很多其他的坑，还在不断优化中。  </p>
<h2 id="总结">总结</h2><p>这次实践其实就是业务中遇到的问题（系统太庞大，调试太麻烦），如何解决问题，如何把解决的思路变成一个解决方案，分享给团队。  </p>
<p>因为自己解决了，和形成一个解决方案还是有非常大的差别的，例如我们在形成方案的过程中，就尝试了很多新东西，踩了很多坑。  </p>
<p>目前还有个坑就是chrome浏览器，调试的Source资源时，如果一个资源重复加载，内存中会更新，但是对应的资源没有更新，导致断点时，映射不对（断点失效），目前暂时的解决方案是，每次请求时添加时间戳，让Source映射的资源强制更新。这个可以正常断点，但是断点没有记忆功能（坑啊，因为文件变了）。</p>
<h2 id="微信公众号">微信公众号</h2><p><img src="/img/weixin.jpg" alt="前端修炼"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/img/weixin.jpg" alt="Yao Tang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Yao Tang</p>
        </div>
        <p class="site-description motion-element" itemprop="description">前端修炼之路</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yao Tang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
